<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sidfate</title>
  
  <subtitle>sidfate&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sidfate.github.io/"/>
  <updated>2018-10-16T08:57:20.778Z</updated>
  <id>https://sidfate.github.io/</id>
  
  <author>
    <name>Sidfate</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>阿尔法·罗密欧</title>
    <link href="https://sidfate.github.io/2018/10/14/car/alfa-romeo/"/>
    <id>https://sidfate.github.io/2018/10/14/car/alfa-romeo/</id>
    <published>2018-10-14T03:20:05.000Z</published>
    <updated>2018-10-16T08:57:20.778Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>走进汽车 - 浪漫意大利风情下的狂野猛兽 - <strong>阿尔法·罗密欧</strong><br><a id="more"></a></p><h3 id="0x00-开始"><a href="#0x00-开始" class="headerlink" title="0x00 开始"></a>0x00 开始</h3><p>阿尔法·罗密欧，作为一个汽车品牌的名字，刚听到的时候就觉得B格十足。这车在世面出现的不多，认识阿斯顿马丁的人可能都要比它多，但它却也是十足的豪华品牌，拥有着悠久的历史文化。</p><h3 id="0x01-历史"><a href="#0x01-历史" class="headerlink" title="0x01 历史"></a>0x01 历史</h3><p>出生于意大利🇮🇹，时尚和文艺之都，创厂历史最早可回溯至1907年，并从1986年开始加入菲亚特集团成为成员品牌之一。车厂原名ALFA（Anonima Lombarda Fabbrica Automobili，伦巴底公有汽车制造厂），但在1916年出身拿波里的实业家尼古拉·罗密欧（Nicola Romeo）入主该车厂，并将自己的家族名加入车厂名称中，而成为今日的阿尔法·罗密欧。</p><p><img src="https://upload.wikimedia.org/wikipedia/zh/2/2a/Alfa_Romeo_logo.png" alt=""></p><p>Alfa Romeo的商标中那条吞食人的蛇代表西元五世纪时米兰维斯孔蒂家族建立者所杀掉的蛇，十字是代表维斯孔蒂家族曾参加十字军东征，后来成为意大利米兰市的市徽。</p><p>以上内容来自于<a href="https://zh.wikipedia.org/wiki/%E9%98%BF%E5%B0%94%E6%B3%95%C2%B7%E7%BD%97%E5%AF%86%E6%AC%A7" target="_blank" rel="noopener">维基百科</a>。不出所料，阿尔法·罗密欧是两个名字结合而来，其中的罗密欧和那个《罗密欧和朱丽叶》没有半毛钱关系，然而有趣的是它旗下有一个车型叫GIULIA（朱丽叶）。</p><p><img src="https://www.alfaromeousa.com/content/dam/alfausa/redesign/desktop/Giulia-VLP/SDP-Gallery/Expanded/AlfaRomeo_2018_VLP_Giulia_Gallery15_expanded_Desktop.jpg.alfaimage.2880.jpg" alt=""></p><p>需要注意一点是，在上面的历史中提到过，阿尔法·罗密欧现在是菲亚特集团的成员品牌。这个菲亚特集团是菲亚特克莱斯勒汽车集团的子部门，菲亚特克莱斯勒汽车集团是菲亚特和克莱斯勒的合并，这里出现了克莱斯勒，请记住它，在文章之后的部分会继续提到。</p><p><img src="https://img.94477.com/1427/1815161/3.jpg" alt=""></p><h3 id="0x02-观察"><a href="#0x02-观察" class="headerlink" title="0x02 观察"></a>0x02 观察</h3><p>如今的阿尔法·罗密欧设计前卫，造型凶悍，追求速度，是时尚和性能的结合体。我就随便放几张图，应该也会有不少人对他的外在心生向往，那就我们就从他的外在说起。</p><p><img src="https://www.alfaromeousa.com/content/dam/alfausa/redesign/desktop/BHP/Hero-Panel/2019-AlfaRomeo-BHP-Hero-3cars.jpg" alt=""></p><p>上图中展示的是现在阿尔法·罗密欧主推的3款车型，分别对应的3种类别的车，跑车 <code>4C Spider</code> ，轿车 <code>GIULIA</code>，SUV <code>STELVIO</code>。可以看出来3款的都应用了家族式的造型，接下来主要介绍的是被大众普遍任何的轿车款 <code>GIULIA</code>。</p><p>首先一看到 <code>GIULIA</code> 家族式的前脸，就足以抓住你的眼球。三叶草☘式的中网造型，醒目的车标点缀，锐利的氙气大灯，以及布满肌肉感的曲线线条，凶悍二个字形容它一点都不夸张。</p><p><img src="https://www.alfaromeousa.com/content/dam/alfausa/2019/Giulia/Desktop/2019-ALFARomeo-VLP-Giulia-SDP-Gallery-1.jpg.alfaimage.2880.jpg" alt=""></p><p>一切都看似那么美好，直到它装上了车牌，整个世界都安静了。</p><p><img src="http://img1.xcarimg.com/drive/22875/23266/640_480_20170312211356167421482043184.jpg" alt=""></p><p>当然我说的可能夸张了，但是逼死强迫症应该是没得跑了，而且车的前脸由于曲线的原因本身就是凹凸不平的，导致强行安上的车牌显得摇摇欲坠，随时都可能掉下来。</p><p>说完前脸我们接着来看侧面：</p><p><img src="https://www.alfaromeousa.com/content/dam/alfausa/redesign/desktop/Giulia-VLP/SDP-Gallery/Expanded/AlfaRomeo_2018_VLP_Giulia_Gallery5_expanded_Desktop.jpg.alfaimage.2880.jpg" alt=""></p><p>看一款车的侧面时候往往就像看一个人的背面，只能看出一个大体的身材。可以看到 <code>GIULIA</code> 侧面上半身比较普通，但它不是那种椭圆形，在靠近前脸的地方，它是一条折线，不是一个整体的曲线，也许是为了突出前脸部分的凶悍吧。<code>GIULIA</code> 下半身就有亮点了，我们可以在车门上能看到一条S型的曲线，比较骚气的腰钱，小蛮腰没毛病。然而前面说的都不重要，我觉得最亮眼的应该是其漂亮的轮毂，花瓣形的轮毂给整个侧面增色不少。</p><p><img src="https://www.alfaromeousa.com/content/dam/alfausa/redesign/desktop/Giulia-VLP/SDP-Gallery/Expanded/AlfaRomeo_2018_VLP_Giulia_Gallery8_expanded_Desktop.jpg.alfaimage.2880.jpg" alt=""></p><p>最后看一下尾部：</p><p><img src="https://www.alfaromeousa.com/content/dam/alfausa/redesign/desktop/Giulia-VLP/SDP-Gallery/Expanded/AlfaRomeo_2018_VLP_Giulia_Gallery9_expanded_Desktop.jpg.alfaimage.2880.jpg" alt=""></p><p>尾部微微上翘的屁股（后备箱处），接近倒三角造型的车灯，底部左右两侧和前脸一致的中网，以及2个圆形排气管。尾部整体是看起来显得平和很多，不过倒三角的车灯还是有点别致的。</p><h3 id="性能篇"><a href="#性能篇" class="headerlink" title="性能篇"></a>性能篇</h3><p>未完待续。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;走进汽车 - 浪漫意大利风情下的狂野猛兽 - &lt;strong&gt;阿尔法·罗密欧&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="car" scheme="https://sidfate.github.io/categories/car/"/>
    
      <category term="brand" scheme="https://sidfate.github.io/categories/car/brand/"/>
    
    
      <category term="car" scheme="https://sidfate.github.io/tags/car/"/>
    
  </entry>
  
  <entry>
    <title>modernphp-fig</title>
    <link href="https://sidfate.github.io/2018/10/14/tech/php/modernphp-fig/"/>
    <id>https://sidfate.github.io/2018/10/14/tech/php/modernphp-fig/</id>
    <published>2018-10-14T02:54:39.000Z</published>
    <updated>2018-10-14T02:58:45.403Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><a id="more"></a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>modernphp-password-date</title>
    <link href="https://sidfate.github.io/2018/10/14/tech/php/modernphp-password-date/"/>
    <id>https://sidfate.github.io/2018/10/14/tech/php/modernphp-password-date/</id>
    <published>2018-10-14T02:54:30.000Z</published>
    <updated>2018-10-14T02:58:50.702Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><a id="more"></a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>modernphp-filter-verification-escape</title>
    <link href="https://sidfate.github.io/2018/10/14/tech/php/modernphp-filter-verification-escape/"/>
    <id>https://sidfate.github.io/2018/10/14/tech/php/modernphp-filter-verification-escape/</id>
    <published>2018-10-14T02:54:17.000Z</published>
    <updated>2018-10-14T02:58:48.404Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><a id="more"></a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>modernphp-psr</title>
    <link href="https://sidfate.github.io/2018/10/14/tech/php/modernphp-psr/"/>
    <id>https://sidfate.github.io/2018/10/14/tech/php/modernphp-psr/</id>
    <published>2018-10-14T02:53:53.000Z</published>
    <updated>2018-10-14T02:58:53.114Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><a id="more"></a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>扫盲篇 - cookie&amp;session</title>
    <link href="https://sidfate.github.io/2018/10/02/tech/literacy/cookie-session/"/>
    <id>https://sidfate.github.io/2018/10/02/tech/literacy/cookie-session/</id>
    <published>2018-10-02T03:33:42.000Z</published>
    <updated>2018-10-14T03:16:59.185Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>试想一下，如果现在突然有一个面试官问你：什么是Cookie？什么是Session？你会怎么回答。<br><a id="more"></a></p><h3 id="0x00-开始"><a href="#0x00-开始" class="headerlink" title="0x00 开始"></a>0x00 开始</h3><p>我想了下，首先大脑中的经验告诉我cookie是客户端缓存信息的一种方式，session则是放在服务端。但是这种说法总觉得有些牵强，于是下面我们从一个具体的请求出发，来看看它们在实际中是怎么应用的。</p><h3 id="0x01-从一个登录的http请求出发"><a href="#0x01-从一个登录的http请求出发" class="headerlink" title="0x01 从一个登录的http请求出发"></a>0x01 从一个登录的http请求出发</h3><!-- 在具体分析请求之前，我们先思考一个问题，在浏览器中，加入我们登录github后，在一定时间段内，我们是不需要重新登录的，也就是说即使关闭了网页或者浏览器，下次进入github还是登录的状态。那么浏览器和github的服务端是怎么实现这种的呢。 --><p>请注意一个前提，http是无状态的协议，无状态导致了服务器不知道客户端处理请求的结果。也就是说我们一个登录流程，用户在网页上输入账号密码并点击登录，浏览器发送登录请求，服务器收到请求并验证用户，记录用户登录状态，然后返回成功登录的信息，最后浏览器收到成功的消息，但是在下次浏览器发送请求时，如果这时候请求没有做特殊的处理，我是无法知道这个用户是否登录的状态。</p><p>在登录请求中，浏览器发送请求后，我们看下服务端做了什么处理：</p><ol><li>设置了session记录当前登录的用户的账号。</li><li>在返回的头信息中有一个特殊头，Set-Cookie，其中包含了sessionId的信息</li></ol><p>sessionId也是服务端自动生成。</p><h3 id="0x02-在app中登录"><a href="#0x02-在app中登录" class="headerlink" title="0x02 在app中登录"></a>0x02 在app中登录</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;试想一下，如果现在突然有一个面试官问你：什么是Cookie？什么是Session？你会怎么回答。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="literacy" scheme="https://sidfate.github.io/categories/tech/literacy/"/>
    
    
      <category term="literacy" scheme="https://sidfate.github.io/tags/literacy/"/>
    
  </entry>
  
  <entry>
    <title>分享篇 - 走进XSS</title>
    <link href="https://sidfate.github.io/2018/09/30/tech/share/front-xss/"/>
    <id>https://sidfate.github.io/2018/09/30/tech/share/front-xss/</id>
    <published>2018-09-30T01:31:28.000Z</published>
    <updated>2018-10-14T03:18:06.620Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>XSS，很耳熟？来看看它到底是什么？<br><a id="more"></a></p><h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>关键词：<code>XSS</code>，<code>html渲染</code>，<code>前端安全</code></p><p><a href="https://xss-game.appspot.com" target="_blank" rel="noopener">一个小游戏</a></p><h3 id="0x01-概念"><a href="#0x01-概念" class="headerlink" title="0x01 概念"></a>0x01 概念</h3><p>“跨站脚本攻击”（Cross Site Scripting)</p><p>第一种分类方式：</p><ol><li>非持久型攻击<br> 顾名思义，非持久型xss攻击是一次性的，仅对当次的页面访问产生影响。非持久型xss攻击要求用户访问一个被攻击者篡改后的链接，用户访问该链接时，被植入的攻击脚本被用户游览器执行，从而达到攻击目的。</li><li>持久型攻击<br> 持久型xss，会把攻击者的数据存储在服务器端，攻击行为将伴随着攻击数据一直存在。</li></ol><p>第二种分类方式：</p><ol><li><p>反射型：经过后端，不经过数据库</p></li><li><p>存储型：经过后端，经过数据库</p></li><li><p>DOM：不经过后端,DOM—based XSS漏洞是基于文档对象模型Document Objeet Model,DOM)的一种漏洞,dom - xss是通过url传入参数去控制触发的</p></li></ol><h3 id="0x02-总结"><a href="#0x02-总结" class="headerlink" title="0x02 总结"></a>0x02 总结</h3><blockquote><p>“大多数职业（从医生到电工），多年的经验等同于多年的专业知识。但是在软件开发中，技术变化如此之快，你花费了大量时间学习技术和工具，一旦这些技术被取代，你的知识将变得毫无价值，因为它们大部分都是实施的细节。最终，所有这些年，你确实积累了一些一般性的经验，但与具体实施相关的知识，你都不再掌握了。<br>唯一留下的是那些基本的东西，你应该专注于软件开发的核心知识和数学知识，您的这些技能会不断增长，而不是随着技术潮流的变化而消失。”</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;XSS，很耳熟？来看看它到底是什么？&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="web" scheme="https://sidfate.github.io/categories/tech/web/"/>
    
    
      <category term="xss" scheme="https://sidfate.github.io/tags/xss/"/>
    
  </entry>
  
  <entry>
    <title>Linux Python安装</title>
    <link href="https://sidfate.github.io/2017/02/21/tech/devops/linux-python-install/"/>
    <id>https://sidfate.github.io/2017/02/21/tech/devops/linux-python-install/</id>
    <published>2017-02-21T01:23:00.000Z</published>
    <updated>2018-10-12T10:16:05.636Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>文本介绍如何在linux中将python更新到最新版本。<br><a id="more"></a></p><h3 id="0x00-前提"><a href="#0x00-前提" class="headerlink" title="0x00 前提"></a>0x00 前提</h3><p>一般来说，linux系统都会自带python，但是python的版本不会是最新的，例如centos6.5的是2.6.6的，接下来我们就将系统的python更新到2.7的最新版本。</p><h3 id="0x00-开始"><a href="#0x00-开始" class="headerlink" title="0x00 开始"></a>0x00 开始</h3><p>首先从官网下载最新版的python</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> wget https://www.python.org/ftp/python/2.7.13/Python-2.7.13.tar.xz</span><br></pre></td></tr></table></figure><p>这个过程可能比较慢，官网下就是很慢orz。下完后解压然后开始安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tar -xvf Python-2.7.13.tar.xz</span><br><span class="line"><span class="meta">$</span> cd Python-2.7.13/</span><br><span class="line"><span class="meta">$</span> ./configure</span><br><span class="line"><span class="meta">$</span> make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>这个过程也会需要一段时间，如果中途报错，基本就是gcc的原因，先更新gcc(<code>yum -y install gcc</code>)再重新安装。默认会将python安装<code>/usr/local/bin/python2.7</code></p><h3 id="0x01-配置"><a href="#0x01-配置" class="headerlink" title="0x01 配置"></a>0x01 配置</h3><p>上述步骤完成后我们来看现在系统中python的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> /usr/local/bin/python2.7 -V</span><br><span class="line">Python 2.7.13</span><br><span class="line"><span class="meta">$</span> python -V</span><br><span class="line">Python 2.6.6</span><br></pre></td></tr></table></figure><p>可以看到我们系统默认的python还是老版本的，说明我们<code>/usr/bin/python</code>仍然指向2.6的python，所以接下来首先给旧版换个名称，然后将<code>/usr/bin/python</code>指向我们新版python的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> mv /usr/bin/python /usr/bin/python26</span><br><span class="line"><span class="meta">$</span> ln -s /usr/local/bin/python2.7 /usr/bin/python </span><br><span class="line"><span class="meta">$</span> python -V</span><br><span class="line">Python 2.7.13</span><br></pre></td></tr></table></figure><p>ok，还剩最后一步，修改yum的配置，因为yum用的是老版本的python，我们更新系统的python后导致yum所使用的python版本不符</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> vi /usr/bin/yum</span><br><span class="line"><span class="meta">#</span>!/usr/bin/python</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>看到没，yum使用的是系统的python，我们将其第一行改成<code>#!/usr/bin/python26</code>就ok了。</p><h3 id="PIP安装"><a href="#PIP安装" class="headerlink" title="PIP安装"></a>PIP安装</h3><p>至此我们python的更新已经完成了，接下来再来安装个pip，pip是python的包管理器，可以说pip之于python类似于npm之于node，可想而知其重要性。关于pip的安装，以下给出一个最实用的安装方式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> wget https://bootstrap.pypa.io/get-pip.py</span><br><span class="line"><span class="meta">$</span> python get-pip.py</span><br></pre></td></tr></table></figure><p>get-pip.py 会根据你的python版本自动安装pip及其依赖包（setuptools）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文本介绍如何在linux中将python更新到最新版本。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="devops" scheme="https://sidfate.github.io/categories/tech/devops/"/>
    
    
      <category term="linux" scheme="https://sidfate.github.io/tags/linux/"/>
    
      <category term="python" scheme="https://sidfate.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Linux 部署node服务</title>
    <link href="https://sidfate.github.io/2017/02/17/tech/devops/linux-node-server/"/>
    <id>https://sidfate.github.io/2017/02/17/tech/devops/linux-node-server/</id>
    <published>2017-02-17T07:01:56.000Z</published>
    <updated>2018-10-14T02:39:19.357Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Linux部署篇 - 如何在linux上不是express的node服务<br><a id="more"></a></p><h3 id="0x00-前提"><a href="#0x00-前提" class="headerlink" title="0x00 前提"></a>0x00 前提</h3><p>这篇文章主要讲的是linux系统下一个express的node项目的部署，express是一个web开发的node框架。</p><h3 id="0x01-过程"><a href="#0x01-过程" class="headerlink" title="0x01 过程"></a>0x01 过程</h3><p>部署工具推荐使用pm2，还有个是forever，但是相对而言pm2用起来更方便的，所以首先我们安装pm2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install pm2 -g</span><br></pre></td></tr></table></figure><p>然后使用pm2创建进程，例如我们这里启动一个express项目，关于pm2的其他使用看<a href="">这里</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 start bin/www</span><br></pre></td></tr></table></figure><p>express默认监听端口是3000，现在你应该已经可以通过<code>http://yourdomain:3000</code>访问你的node项目了，如果还不行看<a href="/linux-firewall-open-port">这里</a>。我们最后还可以使用nginx服务器做代理，修改<code>nginx.conf</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream nodejs &#123; </span><br><span class="line">        server 127.0.0.1:3000; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name youdomain.com;</span><br><span class="line">        location / &#123; </span><br><span class="line">            proxy_pass http://nodejs;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在你应该已经可以直接通过<code>http://yourdomain</code>访问你的node项目了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux部署篇 - 如何在linux上不是express的node服务&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="devops" scheme="https://sidfate.github.io/categories/tech/devops/"/>
    
    
      <category term="linux" scheme="https://sidfate.github.io/tags/linux/"/>
    
      <category term="node" scheme="https://sidfate.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>Python urllib2多线程</title>
    <link href="https://sidfate.github.io/2017/01/21/tech/python/python-urllib2-threads/"/>
    <id>https://sidfate.github.io/2017/01/21/tech/python/python-urllib2-threads/</id>
    <published>2017-01-21T03:26:23.000Z</published>
    <updated>2018-10-12T10:57:31.525Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍怎么使用urllib2和thread让你的爬虫多线程运行。<br><a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock</span><br><span class="line"><span class="keyword">from</span> Queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fetcher</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, threads)</span>:</span></span><br><span class="line">        self.opener = urllib2.build_opener(urllib2.HTTPHandler)</span><br><span class="line">        self.lock = Lock()</span><br><span class="line">        self.q_req = Queue()</span><br><span class="line">        self.q_ans = Queue()</span><br><span class="line">        self.threads = threads</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(threads):</span><br><span class="line">            t = Thread(target=self.get_thread)</span><br><span class="line">            t.setDaemon(<span class="keyword">True</span>)</span><br><span class="line">            t.start()</span><br><span class="line">        self.running = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        self.q_req.join()</span><br><span class="line">        self.q_ans.join()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_task</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.q_req.qsize()+self.q_ans.qsize()+self.running</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, req)</span>:</span></span><br><span class="line">        self.q_req.put(req)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.q_ans.get()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_thread</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            req = self.q_req.get()</span><br><span class="line">            <span class="keyword">with</span> self.lock:</span><br><span class="line">                self.running += <span class="number">1</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                ans = self.opener.open(req).read()</span><br><span class="line">            <span class="keyword">except</span> Exception, what:</span><br><span class="line">                ans = <span class="string">''</span></span><br><span class="line">                <span class="keyword">print</span> what</span><br><span class="line">            self.q_ans.put((req, ans))</span><br><span class="line">            <span class="keyword">with</span> self.lock:</span><br><span class="line">                self.running -= <span class="number">1</span></span><br><span class="line">            self.q_req.task_done()</span><br><span class="line">            time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    links = [<span class="string">'http://www.verycd.com/topics/%d/'</span> % i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5420</span>, <span class="number">5430</span>)]</span><br><span class="line">    f = Fetcher(threads=<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> links:</span><br><span class="line">        f.push(url)</span><br><span class="line">    <span class="keyword">while</span> f.get_task():</span><br><span class="line">        url, content = f.pop()</span><br><span class="line">        <span class="keyword">print</span> url, len(content)</span><br></pre></td></tr></table></figure><blockquote><p>更多爬虫技巧请戳<a href="/spider">传送门</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍怎么使用urllib2和thread让你的爬虫多线程运行。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="python" scheme="https://sidfate.github.io/categories/tech/python/"/>
    
    
      <category term="python" scheme="https://sidfate.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Linux 搭建svn服务器</title>
    <link href="https://sidfate.github.io/2017/01/21/tech/devops/linux-svn-server/"/>
    <id>https://sidfate.github.io/2017/01/21/tech/devops/linux-svn-server/</id>
    <published>2017-01-21T01:40:23.000Z</published>
    <updated>2018-10-14T02:36:45.836Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍在linux搭建自己的svn服务器。<br><a id="more"></a></p><h3 id="0x00-开始"><a href="#0x00-开始" class="headerlink" title="0x00 开始"></a>0x00 开始</h3><ol><li><p>通过yum直接安装subversion</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> yum install subversion</span><br></pre></td></tr></table></figure></li><li><p>创建版本库。版本库是一个svn用来进行版本管理的控制中心，我们将/home/svn作为我们管理所有版本库的目录，然后在其中创建一个project的版本库。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> mkdir /home/svn</span><br><span class="line"><span class="meta">$</span> svnadmin create /home/svn/project</span><br></pre></td></tr></table></figure></li><li><p>修改版本库配置。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd /home/svn/project &amp;&amp; ls</span><br><span class="line">conf  db  format  hooks  locks  README.txt</span><br></pre></td></tr></table></figure><p> 创建完毕的版本库中存在conf，hooks，locks等目录和文件。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd conf/ &amp;&amp; ls</span><br><span class="line">authz  passwd  svnserve.conf</span><br></pre></td></tr></table></figure><p> 进入conf目录我们能看到3个配置文件：authz，passwd，svnserve.conf。authz是svn用户的权限配置文件，passwd是svn用户密码的配置文件，svnserve.conf是版本库的主配置文件。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> vi passwd</span><br></pre></td></tr></table></figure><p> 我们先修改passwd，在文件末尾添加一行表示添加一个用户。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[users]</span><br><span class="line">sidfate = sidfate</span><br></pre></td></tr></table></figure><p> 然后修改authz，在文件末尾添加我们刚刚创建的svn用户对根目录的权限设置，这里我们设置为rw（读写），这里的根目录指的是版本库的根目录。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[/]</span><br><span class="line">sidfate = rw</span><br></pre></td></tr></table></figure><p> 最后修改svnserve.conf，去除下面配置前的注释。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">anon-access = read</span><br><span class="line">auth-access = write</span><br><span class="line">password-db = passwd</span><br><span class="line">authz-db = authz</span><br></pre></td></tr></table></figure><p> 这里说明一下，网上的资料有的说讲<code>realm = My First Repository</code>这一行也去注释，实际测试没有必要，还有如果你在客户端尝试checkout时出现权限验证的错误可以将<code>authz-db = authz</code>这一行注释回去就可以了。</p></li><li><p>启动和关闭svn服务。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> svnserve –d –r /home/svn/project/</span><br></pre></td></tr></table></figure><p>-d指明以守护模式运行，-r指定根目录，还可以使用–listen-port=切换监听端口，默认端口为3690。关闭svn服务可以使用以下命令。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ps -ef | grep svnserve</span><br><span class="line">root      1452   871  0 15:44 pts/0    00:00:00 grep svnserve</span><br><span class="line">root     29508     1  0 Jan20 ?        00:00:00 svnserve -d -r /home/svn/project/</span><br><span class="line"><span class="meta">$</span> kill 29508</span><br></pre></td></tr></table></figure></li><li><p>本地与服务器数据同步。我们现在可以在客户端环境checkout到本地，windows环境下可以使用第三方工具TortoiseSVN，操作很方便，如果是linux客户端，我们可以使用checkout命令。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ svn checkout svn://myurl/project</span><br></pre></td></tr></table></figure><p> 这里有一个误区，没有接触过版本控制的人可能尝试了在本地添加一个文件并上传，然后发现在服务器上找不到上传的文件。实际上版本控制记录了你的提交，你可以在本地的另一处checkout该项目发现你上传的文件已经存在了。在服务器上其实也是同一个道理，你在服务器上同样需要checkout一份代码，我们之前所作的其实就是创建了一个文件控制的中枢，你提交文件到svn服务器，然后在你的服务器上更新代码。也许你会觉得这个步骤繁琐了，别担心，我们可以使用svn的post-commit来自动同步代码的更新，来达到你本地的代码提交后服务器上的代码同步更新的功能。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd /home/svn/project/hooks </span><br><span class="line"><span class="meta">$</span> cp post-commit.tmpl post-commit</span><br><span class="line"><span class="meta">$</span> vi post-commit</span><br></pre></td></tr></table></figure><p> 找到你版本库的hooks目录，拷贝post-commit.tmpl为post-commit，然后编辑该文件，添加以下内容。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REPOS="$1"</span><br><span class="line">REV="$2"</span><br><span class="line">cd /home/wwwroot/project/ &amp;&amp; /usr/bin/svn update --username sidfate --password sidfate</span><br></pre></td></tr></table></figure><p> 注意第三条语句，/home/wwwroot/project/就是我放在服务器上的代码目录，这里的操作就是每次有svn提交后进入该目录然后更新代码。还要注意的是，请给予post-commit足够的权限，不然提交的时候会提示该文件出错。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> chmod 770 post-commit</span><br></pre></td></tr></table></figure><p> 仍然需要注意的一个问题是如果你的svn目录中存在中文命名的文件，那么可能会出现以下类似的错误:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn: Error converting entry in directory &apos;.&apos; to UTF-8</span><br></pre></td></tr></table></figure><p> 这个时候你需要在之前编写的post-commit文件里的命令前加上一段设置编码。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LANG=en_US.UTF-8 &amp;&amp; cd /home/wwwroot/project/ &amp;&amp; /usr/bin/svn update --username sidfate --password sidfate</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍在linux搭建自己的svn服务器。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="devops" scheme="https://sidfate.github.io/categories/tech/devops/"/>
    
    
      <category term="linux" scheme="https://sidfate.github.io/tags/linux/"/>
    
      <category term="svn" scheme="https://sidfate.github.io/tags/svn/"/>
    
  </entry>
  
  <entry>
    <title>Python zip暴力破解</title>
    <link href="https://sidfate.github.io/2016/12/10/tech/python/python-zip-crack/"/>
    <id>https://sidfate.github.io/2016/12/10/tech/python/python-zip-crack/</id>
    <published>2016-12-10T06:34:00.000Z</published>
    <updated>2018-10-14T01:51:54.621Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>网上下到带有密码的zip文件，但是又没有给出密码，着实头疼，不如自动动手用python写一个zip暴力破解程序。<br><a id="more"></a></p><blockquote><p>阅读文本前推荐您先浏览之前的文章：<a href="/tech/python/python-password-dict">Python 创建黑客字典</a></p></blockquote><h3 id="0x00-前提"><a href="#0x00-前提" class="headerlink" title="0x00 前提"></a>0x00 前提</h3><ol><li><p>python提供了对zip文件的操作库zipfile。其中 ZipFile 类中的 extractall() 方法提供了 pwd 参数作为 zip 文件的密码。<a href="https://docs.python.org/2.7/library/zipfile.html" target="_blank" rel="noopener">更多关于 zipfile</a></p></li><li><p>python 中的 optparse 模块可以用来处理命令行参数。其主要使用流程：首先，必须 import OptionParser 类，创建一个 OptionParser 对象，然后，使用 add_option 来定义命令行参数，每个命令行参数就是由参数名字符串和参数属性组成的。最后，一旦你已经定义好了所有的命令行参数，调用 parse_args() 来解析程序的命令行。<a href="https://docs.python.org/2/library/optparse.html" target="_blank" rel="noopener">更多关于 optparse</a></p></li></ol><p>作为测试，我们将我们写一个名为 unzip.py 的脚本来破解密码，在它的同级目录下存在测试文件 test.zip 和字典文件 dict.txt（<a href="/tech/python/python-password-dict">关于字典文件的创建</a>），其中 zip 文件的密码为 123456 。</p><h3 id="0x01-代码"><a href="#0x01-代码" class="headerlink" title="0x01 代码"></a>0x01 代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> optparse</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extractFile</span><span class="params">(zFile, password)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        zFile.extractall(pwd=password)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'[+] Found password '</span> + password + <span class="string">'\n'</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    parser = optparse.OptionParser(<span class="string">"usage%prog -f &lt;zipfile&gt; -d &lt;dictionary&gt;"</span>)</span><br><span class="line">    parser.add_option(<span class="string">'-f'</span>, dest=<span class="string">'zname'</span>, type=<span class="string">'string'</span>, \</span><br><span class="line">                      help=<span class="string">'specify zipfile file'</span>)</span><br><span class="line">    parser.add_option(<span class="string">'-d'</span>, dest=<span class="string">'dname'</span>, type=<span class="string">'string'</span>, \</span><br><span class="line">                      help=<span class="string">'specify dictionary file'</span>)</span><br><span class="line">    (options, args) = parser.parse_args()</span><br><span class="line">    <span class="keyword">if</span> (options.zname == <span class="keyword">None</span>) | (options.dname == <span class="keyword">None</span>):</span><br><span class="line">        <span class="keyword">print</span> parser.usage</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        zname = options.zname</span><br><span class="line">        dname = options.dname</span><br><span class="line">    zFile = zipfile.ZipFile(zname)</span><br><span class="line">    passFile = open(dname)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> passFile.readlines():</span><br><span class="line">        password = line.strip(<span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">if</span> extractFile(zFile, password):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网上下到带有密码的zip文件，但是又没有给出密码，着实头疼，不如自动动手用python写一个zip暴力破解程序。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="python" scheme="https://sidfate.github.io/categories/tech/python/"/>
    
    
      <category term="python" scheme="https://sidfate.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 创建黑客字典</title>
    <link href="https://sidfate.github.io/2016/09/29/tech/python/python-password-dict/"/>
    <id>https://sidfate.github.io/2016/09/29/tech/python/python-password-dict/</id>
    <published>2016-09-29T09:56:00.000Z</published>
    <updated>2018-10-14T01:46:50.953Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文告诉你什么是黑客字典，如何用python轻松的生成黑客常用的密码字典。<br><a id="more"></a></p><h3 id="0x00-前提"><a href="#0x00-前提" class="headerlink" title="0x00 前提"></a>0x00 前提</h3><p>黑客字典，其实就是一些常用的字符集合，往往包含了大量的刻意生成的字符串组合，用来暴力破解某些密码。我们可以用python，只书写几行代码，就可以迭代生成大量我们需要的字符串组合。</p><p>首先简单的介绍下用到的2个库：<strong>string</strong> 和 <strong>itertools</strong>。</p><ul><li>介绍 <strong>string</strong> 模块中几个有用的全局变量：<ul><li>string.letters: <code>abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</code></li><li>string.printable: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">  - string.lowercase: `abcdefghijklmnopqrstuvwxyz`</span><br><span class="line">  - string.uppercase: `ABCDEFGHIJKLMNOPQRSTUVWXYZ`</span><br><span class="line"></span><br><span class="line">* **itertools** 是python的循环器库。循环器是对象的容器，包含有多个对象。`itertools.product()` 的结果为笛卡尔积，相当于一个嵌套循环。`itertools.chain()`将多个循环器结合成单个循环器。[更多关于 itertools](https://docs.python.org/2/library/itertools.html)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 0x01 代码</span><br><span class="line">```python</span><br><span class="line"># !/usr/bin/env python</span><br><span class="line"># coding:utf-8</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">import string</span><br><span class="line">import itertools</span><br><span class="line"></span><br><span class="line">def get_strings():</span><br><span class="line">    chars = string.printable[:10]</span><br><span class="line">    strings = []</span><br><span class="line">    for i in xrange(min, max + 1):</span><br><span class="line">        strings.append((itertools.product(chars, repeat=i),))</span><br><span class="line">    return itertools.chain(*strings)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def make_dict(file, list_str):</span><br><span class="line">    f = open(file, &apos;a&apos;)</span><br><span class="line">    for x in list_str:</span><br><span class="line">        print x</span><br><span class="line">        for y in x:</span><br><span class="line">            f.write(&quot;&quot;.join(y))</span><br><span class="line">            f.write(&apos;\n&apos;)</span><br><span class="line">    f.close()</span><br><span class="line">    print &apos;Done&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    if len(sys.argv) == 4:</span><br><span class="line">        try:</span><br><span class="line">            min = int(sys.argv[1])</span><br><span class="line">            max = int(sys.argv[2])</span><br><span class="line">        except:</span><br><span class="line">            print &quot;wrong&quot;</span><br><span class="line">            sys.exit(0)</span><br><span class="line"></span><br><span class="line">        if min &lt;= max:</span><br><span class="line">            list_str = get_strings()</span><br><span class="line">            file = str(sys.argv[3])</span><br><span class="line">            make_dict(file, list_str)</span><br><span class="line">            sys.exit(0)</span><br><span class="line">    else:</span><br><span class="line">        print &quot;missing some argvs&quot;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="0x02-结果"><a href="#0x02-结果" class="headerlink" title="0x02 结果"></a>0x02 结果</h3><p>这里我们的脚本文件为<code>dict.py</code>，后面的参数分别为密码的最小长度、密码的最大长度以及保存的字典文件名。上面的例子运行成功后会在脚本文件同级目录下生成一个<code>dict.txt</code>的字典文件，其中包含6位随机纯数字的所有组合。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文告诉你什么是黑客字典，如何用python轻松的生成黑客常用的密码字典。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="python" scheme="https://sidfate.github.io/categories/tech/python/"/>
    
    
      <category term="python" scheme="https://sidfate.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>modern-pdo</title>
    <link href="https://sidfate.github.io/2016/09/23/tech/php/modern-pdo/"/>
    <id>https://sidfate.github.io/2016/09/23/tech/php/modern-pdo/</id>
    <published>2016-09-22T20:16:00.000Z</published>
    <updated>2018-10-14T02:58:41.889Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>现代化的php框架基本都继承了PDO，让我们来看看PDO的来源，以及它原生的使用方式。<br><a id="more"></a></p><h3 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h3><p>PDO（PHP Data Objects，PHP数据对象）是一系列的PHP类，抽象了不同数据库的具体实现，提供了统一的接口来操作不同的数据库。</p><h3 id="0x01-数据库连接"><a href="#0x01-数据库连接" class="headerlink" title="0x01 数据库连接"></a>0x01 数据库连接</h3><p>PDO类的构造方法的第一个参数为字符串，指定了DSN（Data Source Name，数据源名称），提供数据连接的详细信息。DSN的开头是数据库驱动器的名称（例如mysql或sqlite），然后接一个”:”号，后面是其他连接信息（主机名、端口号，数据库名和字符集等），更多内容可以查看<a href="http://php.net/manual/en/pdo.drivers.php" target="_blank" rel="noopener">pdo.drivers</a>。PDO类构造方法的第二个参数和第三个参数分别是数据库的用户名和密码。举一个使用的列子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $pdo = <span class="keyword">new</span> PDO(</span><br><span class="line"><span class="string">'mysql:host=127.0.0.1;dbname=books;port=3306;charset=utf8'</span>,</span><br><span class="line">USERNAME,</span><br><span class="line">PASSWORD</span><br><span class="line">);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PDOException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Database connection failed"</span>;</span><br><span class="line">    <span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们不建议使用硬编码的方式写入数据库的连接信息，这样一旦数据库连接出错，很可能就暴露给用户你的PHP代码。所以我们更建议将数据库连接信息写入一个配置文件，然后在主程序中引入配置文件。下面给出一个配置文件的样例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$setting = [</span><br><span class="line"><span class="string">'host'</span>=&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line"><span class="string">'port'</span>=&gt; <span class="number">3306</span>,</span><br><span class="line"><span class="string">'dbname'</span>=&gt; <span class="string">'users'</span>,</span><br><span class="line"><span class="string">'username'</span>=&gt; <span class="string">'USERNAME'</span>,</span><br><span class="line"><span class="string">'password'</span>=&gt; <span class="string">'PASSWORD'</span>,</span><br><span class="line"><span class="string">'charset'</span>=&gt; <span class="string">'utf8'</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="预处理语句"><a href="#预处理语句" class="headerlink" title="预处理语句"></a>预处理语句</h3><p>在SQL语句中使用用户输入的数据一定要过滤，PDO通过预处理语句和参数绑定将过滤输入这项操作变得简单很多。</p><p>预处理语句是<code>PDOStatement</code>的实例。一般可以使用PDO实例的<code>prepare()</code>方法获取预处理语句对象。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">$sql = <span class="string">'SELECT * FROM users WHERE email=:email'</span>;</span><br><span class="line">$statement = $pdo-&gt;prepare($sql);</span><br><span class="line"></span><br><span class="line">$email = filter_input(INPUT_GET, <span class="string">'email'</span>);</span><br><span class="line">$statement-&gt;bindParam(<span class="string">':email'</span>, $email);</span><br></pre></td></tr></table></figure><p>在上面的SQL语句中，<code>:email</code>是具名占位符，可以在<code>$statement</code>实例中通过<code>bindValue()</code>方法绑定为我们需要的值。预处理语句可以自动过滤<code>$email</code>的值，防止SQL注入的发生。在一个SQL语句中可以存在多个多个具名占位符，<code>bindParam()</code>方法提供了第三个参数，指定需要绑定值的数据类型（例如<code>PDO::PARAM_INT</code>，<a href="http://php.net/manual/en/pdo.constants.php" target="_blank" rel="noopener">更多常量</a>），默认的数据类型是字符串。</p><h3 id="查询结果"><a href="#查询结果" class="headerlink" title="查询结果"></a>查询结果</h3><p>有了预处理语句之后，就可以在数据库中执行SQL查询操作了。调用预处理对象的<code>execute()</code>方法后会使用绑定的所有数据执行SQL语句。如果执行的操作是UPDATE，INSERT或DELETE，<code>execute()</code>方法后工作就结束了（当然还可以通过该函数返回TRUE或FALSE判断操作成功与否）。但是如果是SELECT操作，我们还要去获取返回的数据，这时可以通过预处理对象的<code>fetch()</code>，<code>fetchAll()</code>，<code>fetchColumn()</code>或<code>fetchObject()</code>方法获取查询结果。</p><p><code>fetch()</code>用于获取结果数据集的一行，这个方法适用于迭代大型的数据集。<code>fetchAll()</code>可以获取整个数据集，<code>fetch()</code>和<code>fetchAll()</code>的第一个参数为PDO类的<a href="http://php.net/manual/en/pdostatement.fetch.php" target="_blank" rel="noopener">返回方式常量</a>，决定了如何返回查询结果，常用的常量有：</p><ul><li>PDO::FETCH_ASSOC：返回一个以数据库列名为键的关联数组。</li><li>PDO::FETCH_NUM：返回一个以数字为键的关联数组。</li><li>PDO::FETCH_OBJ：返回一个属性名为数据库列名的对象。</li><li>PDO::FETCH_BOTH：返回一个键既包含数据库列名也包含数组的关联数组。</li></ul><p>举一个使用的例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$sql = <span class="string">'SELECT id, name FROM users WHERE email=:email'</span>;</span><br><span class="line">$statement = $pdo-&gt;prepare($sql);</span><br><span class="line"></span><br><span class="line">$email = filter_input(INPUT_GET, <span class="string">'email'</span>);</span><br><span class="line">$statement-&gt;bindParam(<span class="string">':email'</span>, $email);</span><br><span class="line">$statement-&gt;execute();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (($result = $statement-&gt;fetch(PDO::FETCH_ASSOC)) != <span class="keyword">false</span>) &#123;</span><br><span class="line"><span class="keyword">echo</span> $result[<span class="string">'name'</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是指把一系列数据库语句当成单个逻辑单元来处理。也就是说，事务中的一系列sql语句要么都执行成功，要么根本不执行，也就是说事务具有原子性。事务的原子性也保证了数据的一致性，安全性和持久性。事务还能提升性能，因为它实际上是把多个查询排成队列，一次全部执行。</p><p>PDO支持事务，而且使用方便，你只要把构建和执行sql的操作放在PDO实例的<code>beginTransaction()</code>和<code>commit()</code>中。<code>beginTransaction()</code>方法的作用是把后续生成的sql语句排入队列，<code>commit()</code>方法执行原子事务队列中的sql语句。</p><p>下面演示一个未使用事务的例子，其操作是从A账户的钱转入B账户：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'../setting.php'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">$pdo = <span class="keyword">new</span> PDO(</span><br><span class="line">sprintf(</span><br><span class="line"><span class="string">'mysql:host=%s;dbname=%s;port=%s;charset=%s'</span>,</span><br><span class="line">$setting[<span class="string">'host'</span>],</span><br><span class="line">$setting[<span class="string">'dbname'</span>],</span><br><span class="line">$setting[<span class="string">'port'</span>],</span><br><span class="line">$setting[<span class="string">'charset'</span>]</span><br><span class="line">),</span><br><span class="line">$setting[<span class="string">'username'</span>],</span><br><span class="line">$setting[<span class="string">'password'</span>]</span><br><span class="line">);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PDOException $e) &#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Database connection failed"</span>;</span><br><span class="line"><span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$stmtSub = $pdo-&gt;prepare(<span class="string">'</span></span><br><span class="line"><span class="string">UPDATE accounts </span></span><br><span class="line"><span class="string">SET amount = amount - :amount</span></span><br><span class="line"><span class="string">WHERE name = :name</span></span><br><span class="line"><span class="string">'</span>);</span><br><span class="line">$stmtAdd = $pdo-&gt;prepare(<span class="string">'</span></span><br><span class="line"><span class="string">UPDATE accounts </span></span><br><span class="line"><span class="string">SET amount = amount + :amount</span></span><br><span class="line"><span class="string">WHERE name = :name</span></span><br><span class="line"><span class="string">'</span>);</span><br><span class="line"></span><br><span class="line">$fromAccount = <span class="string">'A'</span>;</span><br><span class="line">$toAccount = <span class="string">'B'</span>;</span><br><span class="line">$money = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从A账户取钱</span></span><br><span class="line">$stmtSub-&gt;bindParam(<span class="string">':amount'</span>, $money);</span><br><span class="line">$stmtSub-&gt;bindParam(<span class="string">':name'</span>, $fromAccount);</span><br><span class="line">$stmtSub-&gt;execute();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 钱存入B账户</span></span><br><span class="line">$stmtAdd-&gt;bindParam(<span class="string">':amount'</span>, $money);</span><br><span class="line">$stmtAdd-&gt;bindParam(<span class="string">':name'</span>, $toAccount);</span><br><span class="line">$stmtAdd-&gt;execute();</span><br></pre></td></tr></table></figure><p>这里有一个问题是，当从A账户取钱的操作成功后，发生了一些不可抗拒的错误，导致了后面的把钱加到B账户的操作没有完成，那么这50元就凭空消失了，这显然是不合理的。使用事务我们可以解决这样的问题。下面是使用事务的方式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 开始事务</span></span><br><span class="line">$pdo-&gt;beginTransaction();</span><br><span class="line"></span><br><span class="line">$fromAccount = <span class="string">'jack'</span>;</span><br><span class="line">$toAccount = <span class="string">'rose'</span>;</span><br><span class="line">$money = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从A账户取钱</span></span><br><span class="line">$stmtSub-&gt;bindParam(<span class="string">':amount'</span>, $money);</span><br><span class="line">$stmtSub-&gt;bindParam(<span class="string">':name'</span>, $fromAccount);</span><br><span class="line">$stmtSub-&gt;execute();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 钱存入B账户</span></span><br><span class="line">$stmtAdd-&gt;bindParam(<span class="string">':amount'</span>, $money);</span><br><span class="line">$stmtAdd-&gt;bindParam(<span class="string">':name'</span>, $toAccount);</span><br><span class="line">$stmtAdd-&gt;execute();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交事务</span></span><br><span class="line">$pdo-&gt;commit();</span><br></pre></td></tr></table></figure><blockquote><p>ModernPHP 系列全集：<a href="/modernphp/">传送门</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现代化的php框架基本都继承了PDO，让我们来看看PDO的来源，以及它原生的使用方式。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="php" scheme="https://sidfate.github.io/categories/tech/php/"/>
    
    
      <category term="php" scheme="https://sidfate.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>ModernPHP 闭包</title>
    <link href="https://sidfate.github.io/2016/08/28/tech/php/modernphp-closure/"/>
    <id>https://sidfate.github.io/2016/08/28/tech/php/modernphp-closure/</id>
    <published>2016-08-28T08:51:00.000Z</published>
    <updated>2018-10-14T01:35:59.526Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍PHP中的闭包和匿名函数的概念，以及它们的具体使用。<br><a id="more"></a></p><h3 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h3><p>闭包和匿名函数是PHP5.3.0中引入的特性。下面介绍下这两个概念的定义，可能看上去会比较难理解，但是后面会给出实例可以更好的掌握。</p><p>闭包指的是在创建时封装周围状态的函数。即便闭包所在的环境不存在了，闭包中封装的状态依然存在。</p><p>匿名函数其实是没有名字的函数，匿名函数可以赋值给变量，也能像对象那样被传递，常常被用作函数或者方法的回调。</p><p>理论上讲，闭包和匿名函数是不同的概念，但是PHP将其是做相同的概念。PHP闭包的语法和普通函数相同，但是其实它是伪装成函数的对象，事实上是Closure类的实例。</p><h3 id="0x01-闭包的创建"><a href="#0x01-闭包的创建" class="headerlink" title="0x01 闭包的创建"></a>0x01 闭包的创建</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$closure = <span class="function"><span class="keyword">function</span><span class="params">($name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sprintf(<span class="string">'Hello %s'</span>, $name);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> $closure(<span class="string">"Josh"</span>);</span><br><span class="line"><span class="comment">// 输出 Hello Josh</span></span><br></pre></td></tr></table></figure><p>我们之所以能够调用$closure变量，是因为这个变量的值是一个闭包，而且闭包对象实现了__invoke()魔术方法。只要变量名后有()，PHP就会去查找并调用__invoke()方法。</p><p>很多的PHP函数会用到回调函数，比如array_map()和preg_replace_callback()函数。下面的例子给出了将闭包对象作为回调参数传给array_map()函数。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$numberPlusOne = array_map(<span class="function"><span class="keyword">function</span><span class="params">($nunmber)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $number + <span class="number">1</span>;</span><br><span class="line">&#125;, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"> </span><br><span class="line">print_r($numberPlusOne);</span><br><span class="line"><span class="comment">// 输出 [2, 3, 4]</span></span><br></pre></td></tr></table></figure></p><h3 id="0x01-附加状态"><a href="#0x01-附加状态" class="headerlink" title="0x01 附加状态"></a>0x01 附加状态</h3><p>如果你了解JavaScript的闭包，你应该知道JavaScript的闭包会自动封装引用的状态。但在PHP中并不会，你必须手动调用闭包对象的bindTo()方法或者使用use关键字，把状态附加到PHP闭包中。</p><p>使用use关键字附加状态常见得多，下面给出了例子，use关键字将变量附加到闭包时，附加的变量会记住附加时赋予它的值。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enclosePerson</span><span class="params">($name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">($doCommand)</span> <span class="title">use</span> <span class="params">($name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sprintf(<span class="string">'%s, %s'</span>, $name, $doCommand);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将字符串"Clay"封装在闭包中</span></span><br><span class="line">$clay = enclosePerson(<span class="string">"Clay"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 传入参数，调用闭包</span></span><br><span class="line"><span class="keyword">echo</span> $clay(<span class="string">'go away!'</span>);</span><br><span class="line"><span class="comment">// 输出 "Clay, go away!"</span></span><br></pre></td></tr></table></figure></p><p>上述例子中，enclosePerson函数有一个参数$name，这个函数返回一个闭包对象，并且在闭包对象中封装了$name参数。即便返回的闭包对象跳出了enclosePerson()函数的作用域，$name参数的值还是能获取到，因为$name变量仍在闭包中。</p><p>上面提到过，PHP闭包是对象，它有一个bindTo方法，这个方法可以把Closure对象的内部状态绑定到其他对象上。bindTo的第二个参数很重要，其作用是指定绑定闭包的那个对象所属的PHP类。因此闭包可以访问闭包对象中受保护和私有的成员变量。</p><p>PHP框架经常使用bindTo方法把路由URL映射到匿名函数上。框架会把匿名函数绑定到应用对象上，这么做可以在这个匿名函数中使用$this关键字引用重要的应用对象，下面给出例子。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $routes = [];</span><br><span class="line">    <span class="keyword">protected</span> $responseStatus = <span class="string">"200 OK"</span>;</span><br><span class="line">    <span class="keyword">protected</span> $responseContentType = <span class="string">"text/html"</span>;</span><br><span class="line">    <span class="keyword">protected</span> $responseBody = <span class="string">"Hello world"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addRoute</span><span class="params">($routePath, $routeCallback)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;routes[$routePath] = $routeCallback-&gt;bindTo(<span class="keyword">$this</span>, <span class="keyword">__CLASS__</span>);</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span><span class="params">($currentPath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;routes <span class="keyword">as</span> $routePath =&gt; $callback) &#123;</span><br><span class="line">            <span class="keyword">if</span>($routePath === $currentPath) &#123;</span><br><span class="line">                $callback();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        header(<span class="string">'HTTP/1.1 '</span> . <span class="keyword">$this</span>-&gt;responseStatus);</span><br><span class="line">        header(<span class="string">'Content-type: '</span> . <span class="keyword">$this</span>-&gt;responseContentType);</span><br><span class="line">        header(<span class="string">'Content-length: '</span> . mb_strlen(<span class="keyword">$this</span>-&gt;responseBody));</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;responseBody;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>App类中的addRoute()方法，它有2个参数，分别是路由路径（例如/users/josh）字符串和一个路由回调。dispatch()方法的参数是当前HTTP请求的路径，它会调用匹配的路由回调。第10行是重点，我们把回调函数绑定在了当前的App实例中，这么做就能在回调函数中处理App实例的状态。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$app = <span class="keyword">new</span> App();</span><br><span class="line">$app-&gt;addRoute(<span class="string">'/users/josh'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;responseContentType = <span class="string">'application/json;charset=utf8'</span>;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;responseBody = json_encode([<span class="string">'name'</span>=&gt; <span class="string">'josh'</span>]);</span><br><span class="line">&#125;);</span><br><span class="line">$app-&gt;dispatch(<span class="string">'/users/josh'</span>);</span><br></pre></td></tr></table></figure></p><blockquote><p>ModernPHP 系列全集：<a href="/modernphp/">传送门</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍PHP中的闭包和匿名函数的概念，以及它们的具体使用。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="php" scheme="https://sidfate.github.io/categories/tech/php/"/>
    
    
      <category term="php" scheme="https://sidfate.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>ModernPHP 生成器</title>
    <link href="https://sidfate.github.io/2016/08/28/tech/php/modernphp-generator/"/>
    <id>https://sidfate.github.io/2016/08/28/tech/php/modernphp-generator/</id>
    <published>2016-08-28T08:39:00.000Z</published>
    <updated>2018-10-14T01:36:04.276Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍PHP中生成器的概念，以及它的应用。<br><a id="more"></a></p><h3 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h3><p>PHP生成器是PHP5.5.0引入的功能，生成器就是简单的迭代器，但与标准的PHP迭代器不同，PHP生成器不要求实现Iterator接口，从而减轻了类的负担。生成器会根据需求计算并产出要迭代的值，这对应用性能的影响重大。假如标准的PHP迭代器经常在内存中执行迭代操作，这要预先计算出数据集，性能低下；如果要使用特定的方式计算大量数据，对性能的影响更甚。此时我们使用生成器，即时计算出产出后续值，不占用宝贵的内存资源。</p><p>PHP生成器不能满足所有迭代操作的需求，因为如果不查询，生成器永远不知道下一个要迭代的值是什么，在生成器中无法快进或后退。生成器还是一次性的，无法多次迭代同一个生成器。不过，如果需要，可以重建或克隆生成器。</p><h3 id="0x01-生成器的创建"><a href="#0x01-生成器的创建" class="headerlink" title="0x01 生成器的创建"></a>0x01 生成器的创建</h3><p>生成器的创建很简单，因为生成器就是PHP函数，只不过要在函数中一次或多次使用yield关键字。与普通的PHP函数不同的是，生成器从不返回值，只产出值。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'value1'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'value2'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'value3'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用生成器函数时，PHP会返回一个属于Generator类的对象。这个对象可以使用foreach()函数迭代。每次迭代，PHP会要求Generator实例计算并提供下一个要迭代的值。生成器的优雅体现在，每次产出一个值后，生成器的内部状态会停顿；向生成器请求下一个值时，内部状态又会恢复。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> ($myGenerator <span class="keyword">as</span> $yieldedValue) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $yieldedValue, PHP_EOL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// value1</span></span><br><span class="line"><span class="comment">// value2</span></span><br><span class="line"><span class="comment">// value3</span></span><br></pre></td></tr></table></figure></p><h3 id="0x02-生成器的使用"><a href="#0x02-生成器的使用" class="headerlink" title="0x02 生成器的使用"></a>0x02 生成器的使用</h3><p>下面我们来实现一个简单的函数，用于生成一个大范围内数值集合。</p><p>一个普通的栗子：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRange</span><span class="params">($length)</span> </span>&#123;</span><br><span class="line">    $dataset = [];</span><br><span class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>; $i&lt;$length; $i++) &#123;</span><br><span class="line">        $dataset[] = $i;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> $dataset;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$customRange = makeRange(<span class="number">1000000</span>);</span><br><span class="line"><span class="keyword">foreach</span> ($customRange <span class="keyword">as</span> $i) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $i, PHP_EOL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述的代码没有善用内存，因为makeRange()函数要为预先创建的一个有一百万个整数组成的数组分配内存。PHP生成器实现相同的操作。不过一个只会为一个整数分配内存。</p><p>使用生成器的栗子：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRange</span><span class="params">($length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>; $i&lt;$length; $i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> $i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">foreach</span> (makeRange(<span class="number">1000000</span>) <span class="keyword">as</span> $i) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $i, PHP_EOL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这只是一个虚构的例子，在现实中，你可以想象一下使用生成器可以计算什么样的数据集。假设我们现在想迭代一个4GB的文本文件（例如黑客字典），而你的内存可能比4GB还小，这时候就不能把整个文件加载到内存中，下面使用生成器来实现读取一个cvs文件。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRows</span><span class="params">($file)</span> </span>&#123;</span><br><span class="line">    $handle = fopen($file, <span class="string">'rb'</span>);</span><br><span class="line">    <span class="keyword">if</span>($handle === <span class="keyword">false</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(feof($handle) === <span class="keyword">false</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> fgetcsv($handle);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose($handle);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">foreach</span> (getRows(<span class="string">'data.csv'</span>) <span class="keyword">as</span> $row) &#123;</span><br><span class="line">    print_r($row);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子一次只会为csv文件的一行分配内存。迭代大型数据集或者数列时最适合使用生成器，因为这样占用的系统内存量极少。</p><blockquote><p>ModernPHP 系列全集：<a href="/modernphp/">传送门</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍PHP中生成器的概念，以及它的应用。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="php" scheme="https://sidfate.github.io/categories/tech/php/"/>
    
    
      <category term="php" scheme="https://sidfate.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>ModernPHP 性状</title>
    <link href="https://sidfate.github.io/2016/08/28/tech/php/modernphp-trait/"/>
    <id>https://sidfate.github.io/2016/08/28/tech/php/modernphp-trait/</id>
    <published>2016-08-28T06:30:00.000Z</published>
    <updated>2018-10-12T10:56:56.492Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文讲述了何谓性状，以及PHP中性状出现的意义，怎么去使用。<br><a id="more"></a></p><h3 id="0x00-性状是什么"><a href="#0x00-性状是什么" class="headerlink" title="0x00 性状是什么"></a>0x00 性状是什么</h3><p>这是PHP5.4.0引入的概念，既像类又像接口。性状是类的部分实现（即常量，属性和方法），可以混入一个或多个类中。性状有两个作用：表名类可以做什么（像是接口），提供模块化的实现（像是类）。</p><h3 id="0x01-性状的作用"><a href="#0x01-性状的作用" class="headerlink" title="0x01 性状的作用"></a>0x01 性状的作用</h3><p>PHP语言使用的是典型的继承模型。在这个模型中，我们先创建基类，实现基本的功能，然后扩展这个基类，通过继承基类创建更多具体的类。这叫做继承层次结构，很多编程语言都是用这个模式。</p><p>但是，如果想让两个无关的PHP类具有类型的行为，应该如何去做？例如，Satellite（卫星类）和Car（汽车类）两个类的作用十分不同，在继承层次结构上没有共同的父类，但是这两个类应该都能使用地理编码技术转换成经纬度，然后在地图上显示。</p><p>这时候就可以使用性状来解决。性状可以把模块化的实现方式注入到多个无关的类中，还能促进代码的重用。</p><h3 id="0x02-性状的创建"><a href="#0x02-性状的创建" class="headerlink" title="0x02 性状的创建"></a>0x02 性状的创建</h3><p>定义一个性状：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">trait</span> MyTrait &#123;</span><br><span class="line">    <span class="comment">// 实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们接着使用上面提到的例子来演示如何使用性状。我们希望Satellite和Car类都能提供地理编码功能，而且意识到继承和接口都不是最佳方案。我们选择创建Geocodable（地理编码）性状，返回经纬度，然后在地图中绘制。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">trait</span> Geocodable &#123;</span><br><span class="line">    <span class="comment">/* <span class="doctag">@var</span> string */</span></span><br><span class="line">    <span class="keyword">protected</span> $address;</span><br><span class="line">    <span class="comment">/* <span class="doctag">@var</span> \Geocoder\Geocoder */</span></span><br><span class="line">    <span class="keyword">protected</span> $geocoder;</span><br><span class="line">    <span class="comment">/* <span class="doctag">@var</span> \Geocoder\Result\Geocoded */</span></span><br><span class="line">    <span class="keyword">protected</span> $geocoderResult;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setGeocoder</span><span class="params">(\Geocoder\GeocoderInterface $geocoder)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;geocoder = $geocoder;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setAddress</span><span class="params">($address)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;address = $address;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getLatitude</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;geocoderResult)) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;geocodeAddress();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;geocoderResult-&gt;getLatitude();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getLongitude</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;geocoderResult)) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;geocodeAddress();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;geocoderResult-&gt;getLongitude();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">geocodeAddress</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;geocoderResult = <span class="keyword">$this</span>-&gt;geocoder-&gt;geocode(<span class="keyword">$this</span>-&gt;address);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个Geocodable性状定义了三个类属性：一个表示地址；一个是地理编码器对象（\Geocoder\Geocoder类的实例，这个类是来自第三方的组件）；一个是地理编码器处理后的结果对象（\Geocoder\Result\Geocoded类的实例）。我们还定义了4个公有方法和一个受保护的方法。setGeocoder()方法用于注入Geocoder对象；setAddress()方法用于设定地址；getLatitude()和getLongitude()用于返回经纬度；geocodeAddress()方法把地址字符串传给Geocoder实例，获取地理编码器处理的结果。</p><h3 id="0x03-性状的使用"><a href="#0x03-性状的使用" class="headerlink" title="0x03 性状的使用"></a>0x03 性状的使用</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">MyTrait</span>;</span><br><span class="line">    <span class="comment">// 类的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意，PHP解释器在编译的时候会把性状复制黏贴到类的定义体中，但是不会处理这个操作引入的不兼容问题。如果性状假定类中有特定的方法或属性（在性状中没有定义），要确保相应的类中有对应的属性和方法。</p><blockquote><p>ModernPHP 系列全集：<a href="/modernphp/">传送门</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文讲述了何谓性状，以及PHP中性状出现的意义，怎么去使用。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ModernPHP 命名空间</title>
    <link href="https://sidfate.github.io/2016/08/27/tech/php/modernphp-namespace/"/>
    <id>https://sidfate.github.io/2016/08/27/tech/php/modernphp-namespace/</id>
    <published>2016-08-27T08:28:00.000Z</published>
    <updated>2018-10-14T01:36:08.824Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍PHP中命名空间的相关使用和概念。<br><a id="more"></a></p><h3 id="0x00-声明"><a href="#0x00-声明" class="headerlink" title="0x00 声明"></a>0x00 声明</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Symfony</span>\<span class="title">Component</span>\<span class="title">HttpFoundation</span>;</span><br></pre></td></tr></table></figure><p>这一行代码是PHP命名空间声明语句。声明语句始终应该放在<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PHP命名空间与操作系统的物理文件系统不同，这是一个虚拟的概念，没必要和文件系统的目录结构完全对应。但是，大多数的PHP组件为了兼容广泛使用的[PSR-4自动加载器标准](https://phphub.org/topics/2081)，会把子命名空间放到文件系统的子目录下。</span><br><span class="line"></span><br><span class="line">### 0x01 导入</span><br><span class="line">```php</span><br><span class="line">use Symfony\Component\HttpFoundation\Response;</span><br><span class="line"> </span><br><span class="line">$r = new Response();</span><br></pre></td></tr></table></figure></p><p>当然，你还可以用别名的方式导入：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Symfony</span>\<span class="title">Component</span>\<span class="title">HttpFoundation</span>\<span class="title">Response</span> <span class="title">as</span> <span class="title">Res</span>;</span><br><span class="line"> </span><br><span class="line">$r = <span class="keyword">new</span> Res();</span><br></pre></td></tr></table></figure></p><p>应该在PHP文件顶部使用use关键字导入代码，而且要放在<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">从PHP5.6开始还可以导入函数和常量。导入函数时需要使用use func，导入常量时使用use constant。</span><br><span class="line">```php</span><br><span class="line">use func Namespace\funcName;</span><br><span class="line">use constant Namespace\CONST_NAME;</span><br><span class="line"> </span><br><span class="line">funcName();</span><br><span class="line">echo CONST_NAME;</span><br></pre></td></tr></table></figure></p><h3 id="0x02-全局命名空间"><a href="#0x02-全局命名空间" class="headerlink" title="0x02 全局命名空间"></a>0x02 全局命名空间</h3><p>如果需要在命名空间中引用其他命名空间的类、接口、函数或常量，必须使用完全限定的PHP类名（命名空间+类名），或者使用use关键字提前导入至当前命名空间。</p><p>有些代码没有命名空间，这些代码在全局命名空间中，例如PHP原生的Exception类。在命名空间中引入全局命名空间的代码时，需要在类、接口、函数或者常量前加上\符号。例如下面这个例子中，<figure class="highlight plain"><figcaption><span>方法会报错，因为PHP会去搜索当前命名空间下的Exception，也就是会去搜索\My\Space\Foo\Exception类，但是这个类不存在。因此我们需要在Exception类前加上\前缀，表名要去全局命名空间中查找该类。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">一个错误的栗子：</span><br><span class="line">```php</span><br><span class="line">namespace My\Space;</span><br><span class="line">class Foo()</span><br><span class="line">&#123;</span><br><span class="line">    public function run()</span><br><span class="line">    &#123;</span><br><span class="line">        $e = new Exception();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>真确的栗子：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">My</span>\<span class="title">Space</span>;</span><br><span class="line">class Foo()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $e = <span class="keyword">new</span> \<span class="keyword">Exception</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>ModernPHP 系列全集：<a href="/modernphp/">传送门</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍PHP中命名空间的相关使用和概念。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="php" scheme="https://sidfate.github.io/categories/tech/php/"/>
    
    
      <category term="php" scheme="https://sidfate.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>Linux 定时任务crontab</title>
    <link href="https://sidfate.github.io/2016/08/22/tech/devops/linux-crontab/"/>
    <id>https://sidfate.github.io/2016/08/22/tech/devops/linux-crontab/</id>
    <published>2016-08-22T09:12:00.000Z</published>
    <updated>2018-10-14T02:47:04.965Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Linux部署篇 - 如何使用crontab完成定时任务。<br><a id="more"></a></p><h3 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h3><p>对应于windows中的定时计划，linux 中有个crontab来处理定时任务。那么常见的定时任务有哪些呢，例如每天凌晨1点自动备份数据库，每隔1小时执行爬虫脚本爬取信息等等。</p><h3 id="0x01-常用命令"><a href="#0x01-常用命令" class="headerlink" title="0x01 常用命令"></a>0x01 常用命令</h3><ul><li><code>crontab -l</code> 列出当前的的定时任务，或者<code>vi /etc/crontab</code></li><li><code>crontab -e</code> 编辑定时脚本</li></ul><h3 id="0x02-添加任务"><a href="#0x02-添加任务" class="headerlink" title="0x02 添加任务"></a>0x02 添加任务</h3><p>分　时　日　月　周 command</p><ul><li>第1列表示分钟1～59 每分钟用<em>或者 </em>/1表示 </li><li>第2列表示小时1～23（0表示0点） </li><li>第3列表示日期1～31 </li><li>第4列表示月份1～12 </li><li>第5列标识号星期0～6（0表示星期天） </li><li>第6列要运行的命令 </li></ul><p>一些例子：</p><ol><li><p>每隔一分钟执行<code>root /opt/bin/test-cron.sh</code></p><pre><code>*/1 * * * * root /opt/bin/test-cron.sh  </code></pre></li><li><p>每天4点执行<code>/home/dbbackup/db2backup.sh backup</code></p><pre><code>0 4 * * * /home/dbbackup/db2backup.sh backup</code></pre></li></ol><h3 id="0x02-注意"><a href="#0x02-注意" class="headerlink" title="0x02 注意"></a>0x02 注意</h3><ol><li><p>查看任务执行</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tail -f /var/log/cron</span><br></pre></td></tr></table></figure></li><li><p>如果你的crontab没有生效，你得查看下<code>crond</code>服务有没有开启</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> service crond status</span><br><span class="line"><span class="meta">$</span> service crond restart</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux部署篇 - 如何使用crontab完成定时任务。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="devops" scheme="https://sidfate.github.io/categories/tech/devops/"/>
    
    
      <category term="linux" scheme="https://sidfate.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Apache 开启.htaccess</title>
    <link href="https://sidfate.github.io/2016/08/03/tech/devops/apache-start-htaccess/"/>
    <id>https://sidfate.github.io/2016/08/03/tech/devops/apache-start-htaccess/</id>
    <published>2016-08-03T09:34:00.000Z</published>
    <updated>2018-10-12T10:13:50.890Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍apache开启htaccess配置的方法。</p><a id="more"></a><h3 id="0x00-开始"><a href="#0x00-开始" class="headerlink" title="0x00 开始"></a>0x00 开始</h3><ol><li>找到apache配置文件<code>httpd.conf</code>，找到 </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#LoadModule rewrite_module modules/mod_rewrite.so</span><br></pre></td></tr></table></figure><p>去掉前面的注释符号#。并确认apache安装目录下的modules文件夹中是否有<code>mod_rewrite.so</code>这个文件。这样就启用了Mod Rewrite功能。</p><ol start="2"><li>搜索AllowOverride，找到以下类似配置</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory /&gt;</span><br><span class="line">Options FollowSymLinks</span><br><span class="line">AllowOverride None</span><br><span class="line">Order deny,allow</span><br><span class="line">Deny from all</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure><p>把<code>AllowOverride None</code>改成<code>AllowOverride All</code>，这样所有的文件夹都支持.htaccess了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍apache开启htaccess配置的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="devops" scheme="https://sidfate.github.io/categories/tech/devops/"/>
    
    
      <category term="Apache" scheme="https://sidfate.github.io/tags/Apache/"/>
    
  </entry>
  
</feed>
