<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sidfate</title>
  
  <subtitle>sidfate&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sidfate.github.io/"/>
  <updated>2018-11-08T09:39:53.362Z</updated>
  <id>https://sidfate.github.io/</id>
  
  <author>
    <name>Sidfate</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>商城的重构</title>
    <link href="https://sidfate.github.io/2018/11/08/share-store/"/>
    <id>https://sidfate.github.io/2018/11/08/share-store/</id>
    <published>2018-11-08T09:32:25.000Z</published>
    <updated>2018-11-08T09:39:53.362Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>商城分享<br><a id="more"></a></p><h1 id="Gstore-项目重构"><a href="#Gstore-项目重构" class="headerlink" title="Gstore 项目重构"></a>Gstore 项目重构</h1><h3 id="为什么要重构？"><a href="#为什么要重构？" class="headerlink" title="为什么要重构？"></a>为什么要重构？</h3><p><a href="https://i.loli.net/2018/11/08/5be4017431b23.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/11/08/5be4017431b23.png" alt="商城.png"></a><br><a href="https://i.loli.net/2018/11/08/5be401742ff44.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/11/08/5be401742ff44.png" alt="商城体系-商品.png"></a><br><a href="https://i.loli.net/2018/11/08/5be40174283fb.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/11/08/5be40174283fb.png" alt="商城体系-订单.png"></a></p><p>主要原因有2个：</p><ol><li>当前商城的数据库中包含了太多无用的表或者结构，这些结构从一定程度上也影响了新需求的设计。也有很多结构是冗余的，无用的，设计不合理的，例如订单中保存了多个车辆相关的字段，msisdn，vin等等，这些实际上跟订单这个业务并不是完全关联的，可能只有部分场景相关。</li><li>现在4个商城的代码混杂在一个商城的项目中，这个项目中也混杂了多个领域的业务，商品库存、订单、分类、品牌、banner、优惠活动。最直接导致的一个问题就是，比如一个新需求是针对应用商城安装包（也被视为一个商品）的，那么一旦去做这个新需求，发生一些数据库或者代码的改动，其结果很可能会影响到其他的商城（虽然在代码中现在已经做了一些商城的分离处理，但是还是难免会有遗漏）。</li></ol><h3 id="怎么重构？"><a href="#怎么重构？" class="headerlink" title="怎么重构？"></a>怎么重构？</h3><p>结合上两条问题的起因，我们将整个商城也分为2步重构。</p><ol><li>拆分各个商城，抽离出各个具象的业务，以及保留商城元系统。</li><li>抽象化商城元系统，并拆分系统领域，即拆分子系统。</li></ol><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p><strong>子系统</strong>：</p><ul><li>tsp-store 商城库存系统<br>  商城元数据的系统</li><li>tsp-order 订单系统<br>  处理订单业务的系统</li><li>tsp-activity 商城活动系统<br>  处理商城活动相关业务的系统</li></ul><p><strong>具象系统</strong>：</p><ul><li>tsp-app-store 应用商城系统</li><li>tsp-theme-store 主题商城系统</li><li>tsp-point-store 积分商城系统</li><li>tsp-flow-store 流量商城系统</li></ul><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p>库存系统表结构：<br><img src="https://i.loli.net/2018/11/08/5be401f371375.png" alt="库存系统表结构.png"></p><p>应用商城表结构：</p><p><img src="https://i.loli.net/2018/11/08/5be401f36cefe.png" alt="应用商城表结构.png"></p><p>主题商城表结构：</p><p><img src="https://i.loli.net/2018/11/08/5be401f36b51e.png" alt="主题商城表结构.png"></p><p>订单系统表结构：</p><p><img src="https://i.loli.net/2018/11/08/5be401f36f0f4.png" alt="订单系统表结构.png"></p><p><strong>优点</strong>：</p><ul><li>各个商城专注于自己的业务，新业务没有耦合。</li><li>商城拆分成3个子系统，减少子系统之间的耦合。</li><li>后续维护方便，新来的同事也能很快入手，系统的扩展性也更好。</li></ul><p><strong>缺点</strong>：</p><ul><li>tsp-store中的元数据混在一起，单纯的作为一个仓库。</li><li>一定量上肯定是加大了开发成本。</li></ul><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><ol><li>像tsp-store这种元系统，本身只是提供给其他服务用，不提供对外的接口，这种服务是否符合微服务的整体架构？</li><li>如何很好的抽象出元数据？这个是比较重要的步骤，因为一旦元系统的结构变动，会影响到上层的服务（或者这里可以在元数据提供的入口中做一些低内聚的操作）</li><li>未来比较麻烦的一点是，为了兼容老商城的部分，新的商城系统主要负责做新的需求，如何能最大程度上从旧的商城剥离出来，这也是个需要注意的地方。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;商城分享&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>音乐篇 - 纯真</title>
    <link href="https://sidfate.github.io/2018/10/28/art/music/%E7%BA%AF%E7%9C%9F/"/>
    <id>https://sidfate.github.io/2018/10/28/art/music/纯真/</id>
    <published>2018-10-28T02:01:21.000Z</published>
    <updated>2018-10-28T02:20:52.286Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>无声之中你拉起我的手，我怎么感觉整个黑夜在颤动。<br><a id="more"></a></p><p>这首歌总让我想起一个故事，是别人的故事，还是自己的故事，却无法分辨。</p><p>出自五月天，但是我更喜欢梁静茹的版本。</p>        <div id="aplayer-woiHbSIU" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-woiHbSIU"),            narrow: false,            autoplay: true,            showlrc: 3,            music: {              title: "纯真",              author: "梁静茹",              url: "http://dl.stream.qqmusic.qq.com/M800000S8aM11HmBOI.mp3?vkey=5BF86328B6BFBFF0E487DF35B130AEF9CD82407C71342162642CCEBB2F6D28D3777B362B251C4CD2601A1D9397160637621E3C003D37ED60&guid=5150825362&fromtag=1",              pic: "http://y.gtimg.cn/music/photo_new/T002R300x300M000003fXCg33QEqj2.jpg",              lrc: "https://sidfate.oss-cn-hangzhou.aliyuncs.com/lrc/%E7%BA%AF%E7%9C%9F-%E6%A2%81%E9%9D%99%E8%8C%B9.lrc"            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无声之中你拉起我的手，我怎么感觉整个黑夜在颤动。&lt;br&gt;
    
    </summary>
    
      <category term="art" scheme="https://sidfate.github.io/categories/art/"/>
    
      <category term="music" scheme="https://sidfate.github.io/categories/art/music/"/>
    
    
      <category term="music" scheme="https://sidfate.github.io/tags/music/"/>
    
  </entry>
  
  <entry>
    <title>纽北赛道</title>
    <link href="https://sidfate.github.io/2018/10/16/car/nurburgring/"/>
    <id>https://sidfate.github.io/2018/10/16/car/nurburgring/</id>
    <published>2018-10-16T08:58:29.000Z</published>
    <updated>2018-10-16T09:30:47.097Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>小伙子，你开什么车啊？纽北赛道跑一跑？<br><a id="more"></a></p><p>我们常说的纽北赛道其实是指的纽博格林赛道的北赛道。纽博格林赛道（德语：Nürburgring，意指“纽堡的环道”）是一条位于德国莱茵兰-普法尔茨州的赛车跑道。最早修筑于1920年代，该赛道围绕着埃菲尔山区一称为纽堡的小村与中世纪古堡而建。由于跑道长度非常长（根据时代与设定的不同，该跑道最长距离曾长达28公里以上）、地形复杂充满挑战性，除了经常被认为是世界上最严苛、为了竞赛用途而建造的赛道之外[1]，也经常被用作新款的量产车种上市之前进行耐久与性能实测的常用场地。苏格兰一级方程式传奇赛车手杰基·斯图尔特曾因此跑道的路线严苛，而称呼北环为“绿色地狱”（Green Hell），并在赛车界中广为流传[2]。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小伙子，你开什么车啊？纽北赛道跑一跑？&lt;br&gt;
    
    </summary>
    
      <category term="car" scheme="https://sidfate.github.io/categories/car/"/>
    
    
      <category term="car" scheme="https://sidfate.github.io/tags/car/"/>
    
  </entry>
  
  <entry>
    <title>阿尔法·罗密欧</title>
    <link href="https://sidfate.github.io/2018/10/14/car/alfa-romeo/"/>
    <id>https://sidfate.github.io/2018/10/14/car/alfa-romeo/</id>
    <published>2018-10-14T03:20:05.000Z</published>
    <updated>2018-10-16T09:27:40.061Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>走进汽车 - 浪漫意大利风情下的狂野猛兽 - <strong>阿尔法·罗密欧</strong><br><a id="more"></a></p><h3 id="0x00-开始"><a href="#0x00-开始" class="headerlink" title="0x00 开始"></a>0x00 开始</h3><p>阿尔法·罗密欧，作为一个汽车品牌的名字，刚听到的时候就觉得B格十足。这车在世面出现的不多，认识阿斯顿马丁的人可能都要比它多，但它却也是十足的豪华品牌，拥有着悠久的历史文化。</p><h3 id="0x01-历史"><a href="#0x01-历史" class="headerlink" title="0x01 历史"></a>0x01 历史</h3><p>出生于意大利🇮🇹，时尚和文艺之都，创厂历史最早可回溯至1907年，并从1986年开始加入菲亚特集团成为成员品牌之一。车厂原名ALFA（Anonima Lombarda Fabbrica Automobili，伦巴底公有汽车制造厂），但在1916年出身拿波里的实业家尼古拉·罗密欧（Nicola Romeo）入主该车厂，并将自己的家族名加入车厂名称中，而成为今日的阿尔法·罗密欧。</p><p><img src="https://upload.wikimedia.org/wikipedia/zh/2/2a/Alfa_Romeo_logo.png" alt=""></p><p>Alfa Romeo的商标中那条吞食人的蛇代表西元五世纪时米兰维斯孔蒂家族建立者所杀掉的蛇，十字是代表维斯孔蒂家族曾参加十字军东征，后来成为意大利米兰市的市徽。</p><p>以上内容来自于<a href="https://zh.wikipedia.org/wiki/%E9%98%BF%E5%B0%94%E6%B3%95%C2%B7%E7%BD%97%E5%AF%86%E6%AC%A7" target="_blank" rel="noopener">维基百科</a>。不出所料，阿尔法·罗密欧是两个名字结合而来，其中的罗密欧和那个《罗密欧和朱丽叶》没有半毛钱关系，然而有趣的是它旗下有一个车型叫GIULIA（朱丽叶）。</p><p><img src="https://www.alfaromeousa.com/content/dam/alfausa/redesign/desktop/Giulia-VLP/SDP-Gallery/Expanded/AlfaRomeo_2018_VLP_Giulia_Gallery15_expanded_Desktop.jpg.alfaimage.2880.jpg" alt=""></p><p>需要注意一点是，在上面的历史中提到过，阿尔法·罗密欧现在是菲亚特集团的成员品牌。这个菲亚特集团是菲亚特克莱斯勒汽车集团的子部门，菲亚特克莱斯勒汽车集团是菲亚特和克莱斯勒的合并，这里出现了克莱斯勒，请记住它，在文章之后的部分会继续提到。</p><p><img src="https://img.94477.com/1427/1815161/3.jpg" alt=""></p><h3 id="0x02-观察"><a href="#0x02-观察" class="headerlink" title="0x02 观察"></a>0x02 观察</h3><p>如今的阿尔法·罗密欧设计前卫，造型凶悍，追求速度，是时尚和性能的结合体。我就随便放几张图，应该也会有不少人对他的外在心生向往，那就我们就从他的外在说起。</p><p><img src="https://www.alfaromeousa.com/content/dam/alfausa/redesign/desktop/BHP/Hero-Panel/2019-AlfaRomeo-BHP-Hero-3cars.jpg" alt=""></p><p>上图中展示的是现在阿尔法·罗密欧主推的3款车型，分别对应的3种类别的车，跑车 <code>4C Spider</code> ，轿车 <code>GIULIA</code>，SUV <code>STELVIO</code>。可以看出来3款的都应用了家族式的造型，接下来主要介绍的是被大众普遍任何的轿车款 <code>GIULIA</code>。</p><p>首先一看到 <code>GIULIA</code> 家族式的前脸，就足以抓住你的眼球。三叶草☘式的中网造型，醒目的车标点缀，锐利的氙气大灯，以及布满肌肉感的曲线线条，凶悍二个字形容它一点都不夸张。</p><p><img src="https://www.alfaromeousa.com/content/dam/alfausa/2019/Giulia/Desktop/2019-ALFARomeo-VLP-Giulia-SDP-Gallery-1.jpg.alfaimage.2880.jpg" alt=""></p><p>一切都看似那么美好，直到它装上了车牌，整个世界都安静了。</p><p><img src="http://img1.xcarimg.com/drive/22875/23266/640_480_20170312211356167421482043184.jpg" alt=""></p><p>当然我说的可能夸张了，但是逼死强迫症应该是没得跑了，而且车的前脸由于曲线的原因本身就是凹凸不平的，导致强行安上的车牌显得摇摇欲坠，随时都可能掉下来。</p><p>说完前脸我们接着来看侧面：</p><p><img src="https://www.alfaromeousa.com/content/dam/alfausa/redesign/desktop/Giulia-VLP/SDP-Gallery/Expanded/AlfaRomeo_2018_VLP_Giulia_Gallery5_expanded_Desktop.jpg.alfaimage.2880.jpg" alt=""></p><p>看一款车的侧面时候往往就像看一个人的背面，只能看出一个大体的身材。可以看到 <code>GIULIA</code> 侧面上半身比较普通，但它不是那种椭圆形，在靠近前脸的地方，它是一条折线，不是一个整体的曲线，也许是为了突出前脸部分的凶悍吧。<code>GIULIA</code> 下半身就有亮点了，我们可以在车门上能看到一条S型的曲线，比较骚气的腰钱，小蛮腰没毛病。然而前面说的都不重要，我觉得最亮眼的应该是其漂亮的轮毂，花瓣形的轮毂给整个侧面增色不少。</p><p><img src="https://www.alfaromeousa.com/content/dam/alfausa/redesign/desktop/Giulia-VLP/SDP-Gallery/Expanded/AlfaRomeo_2018_VLP_Giulia_Gallery8_expanded_Desktop.jpg.alfaimage.2880.jpg" alt=""></p><p>最后看一下尾部：</p><p><img src="https://www.alfaromeousa.com/content/dam/alfausa/redesign/desktop/Giulia-VLP/SDP-Gallery/Expanded/AlfaRomeo_2018_VLP_Giulia_Gallery9_expanded_Desktop.jpg.alfaimage.2880.jpg" alt=""></p><p>尾部微微上翘的屁股（后备箱处），接近倒三角造型的车灯，底部左右两侧和前脸一致的中网，以及2个圆形排气管。尾部整体是看起来显得平和很多，不过倒三角的车灯还是有点别致的，这造型会不会让你想到某位同门兄弟呢😏。</p><p><img src="http://01.imgmini.eastday.com/mobile/20170920/20170920174424_7143c7a78a716216d9d1177697832bee_4.jpeg" alt=""></p><h3 id="性能篇"><a href="#性能篇" class="headerlink" title="性能篇"></a>性能篇</h3><p>未完待续。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;走进汽车 - 浪漫意大利风情下的狂野猛兽 - &lt;strong&gt;阿尔法·罗密欧&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="car" scheme="https://sidfate.github.io/categories/car/"/>
    
      <category term="brand" scheme="https://sidfate.github.io/categories/car/brand/"/>
    
    
      <category term="car" scheme="https://sidfate.github.io/tags/car/"/>
    
  </entry>
  
  <entry>
    <title>扫盲篇 - cookie&amp;session</title>
    <link href="https://sidfate.github.io/2018/10/02/tech/literacy/cookie-session/"/>
    <id>https://sidfate.github.io/2018/10/02/tech/literacy/cookie-session/</id>
    <published>2018-10-02T03:33:42.000Z</published>
    <updated>2018-10-14T03:16:59.185Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>试想一下，如果现在突然有一个面试官问你：什么是Cookie？什么是Session？你会怎么回答。<br><a id="more"></a></p><h3 id="0x00-开始"><a href="#0x00-开始" class="headerlink" title="0x00 开始"></a>0x00 开始</h3><p>我想了下，首先大脑中的经验告诉我cookie是客户端缓存信息的一种方式，session则是放在服务端。但是这种说法总觉得有些牵强，于是下面我们从一个具体的请求出发，来看看它们在实际中是怎么应用的。</p><h3 id="0x01-从一个登录的http请求出发"><a href="#0x01-从一个登录的http请求出发" class="headerlink" title="0x01 从一个登录的http请求出发"></a>0x01 从一个登录的http请求出发</h3><!-- 在具体分析请求之前，我们先思考一个问题，在浏览器中，加入我们登录github后，在一定时间段内，我们是不需要重新登录的，也就是说即使关闭了网页或者浏览器，下次进入github还是登录的状态。那么浏览器和github的服务端是怎么实现这种的呢。 --><p>请注意一个前提，http是无状态的协议，无状态导致了服务器不知道客户端处理请求的结果。也就是说我们一个登录流程，用户在网页上输入账号密码并点击登录，浏览器发送登录请求，服务器收到请求并验证用户，记录用户登录状态，然后返回成功登录的信息，最后浏览器收到成功的消息，但是在下次浏览器发送请求时，如果这时候请求没有做特殊的处理，我是无法知道这个用户是否登录的状态。</p><p>在登录请求中，浏览器发送请求后，我们看下服务端做了什么处理：</p><ol><li>设置了session记录当前登录的用户的账号。</li><li>在返回的头信息中有一个特殊头，Set-Cookie，其中包含了sessionId的信息</li></ol><p>sessionId也是服务端自动生成。</p><h3 id="0x02-在app中登录"><a href="#0x02-在app中登录" class="headerlink" title="0x02 在app中登录"></a>0x02 在app中登录</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;试想一下，如果现在突然有一个面试官问你：什么是Cookie？什么是Session？你会怎么回答。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="literacy" scheme="https://sidfate.github.io/categories/tech/literacy/"/>
    
    
      <category term="literacy" scheme="https://sidfate.github.io/tags/literacy/"/>
    
  </entry>
  
  <entry>
    <title>分享篇 - 走进XSS</title>
    <link href="https://sidfate.github.io/2018/09/30/tech/share/front-xss/"/>
    <id>https://sidfate.github.io/2018/09/30/tech/share/front-xss/</id>
    <published>2018-09-30T01:31:28.000Z</published>
    <updated>2018-10-14T03:18:06.620Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>XSS，很耳熟？来看看它到底是什么？<br><a id="more"></a></p><h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>关键词：<code>XSS</code>，<code>html渲染</code>，<code>前端安全</code></p><p><a href="https://xss-game.appspot.com" target="_blank" rel="noopener">一个小游戏</a></p><h3 id="0x01-概念"><a href="#0x01-概念" class="headerlink" title="0x01 概念"></a>0x01 概念</h3><p>“跨站脚本攻击”（Cross Site Scripting)</p><p>第一种分类方式：</p><ol><li>非持久型攻击<br> 顾名思义，非持久型xss攻击是一次性的，仅对当次的页面访问产生影响。非持久型xss攻击要求用户访问一个被攻击者篡改后的链接，用户访问该链接时，被植入的攻击脚本被用户游览器执行，从而达到攻击目的。</li><li>持久型攻击<br> 持久型xss，会把攻击者的数据存储在服务器端，攻击行为将伴随着攻击数据一直存在。</li></ol><p>第二种分类方式：</p><ol><li><p>反射型：经过后端，不经过数据库</p></li><li><p>存储型：经过后端，经过数据库</p></li><li><p>DOM：不经过后端,DOM—based XSS漏洞是基于文档对象模型Document Objeet Model,DOM)的一种漏洞,dom - xss是通过url传入参数去控制触发的</p></li></ol><h3 id="0x02-总结"><a href="#0x02-总结" class="headerlink" title="0x02 总结"></a>0x02 总结</h3><blockquote><p>“大多数职业（从医生到电工），多年的经验等同于多年的专业知识。但是在软件开发中，技术变化如此之快，你花费了大量时间学习技术和工具，一旦这些技术被取代，你的知识将变得毫无价值，因为它们大部分都是实施的细节。最终，所有这些年，你确实积累了一些一般性的经验，但与具体实施相关的知识，你都不再掌握了。<br>唯一留下的是那些基本的东西，你应该专注于软件开发的核心知识和数学知识，您的这些技能会不断增长，而不是随着技术潮流的变化而消失。”</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;XSS，很耳熟？来看看它到底是什么？&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="web" scheme="https://sidfate.github.io/categories/tech/web/"/>
    
    
      <category term="xss" scheme="https://sidfate.github.io/tags/xss/"/>
    
  </entry>
  
  <entry>
    <title>Linux Python安装</title>
    <link href="https://sidfate.github.io/2017/02/21/tech/devops/linux-python-install/"/>
    <id>https://sidfate.github.io/2017/02/21/tech/devops/linux-python-install/</id>
    <published>2017-02-21T01:23:00.000Z</published>
    <updated>2018-10-12T10:16:05.636Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>文本介绍如何在linux中将python更新到最新版本。<br><a id="more"></a></p><h3 id="0x00-前提"><a href="#0x00-前提" class="headerlink" title="0x00 前提"></a>0x00 前提</h3><p>一般来说，linux系统都会自带python，但是python的版本不会是最新的，例如centos6.5的是2.6.6的，接下来我们就将系统的python更新到2.7的最新版本。</p><h3 id="0x00-开始"><a href="#0x00-开始" class="headerlink" title="0x00 开始"></a>0x00 开始</h3><p>首先从官网下载最新版的python</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> wget https://www.python.org/ftp/python/2.7.13/Python-2.7.13.tar.xz</span><br></pre></td></tr></table></figure><p>这个过程可能比较慢，官网下就是很慢orz。下完后解压然后开始安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tar -xvf Python-2.7.13.tar.xz</span><br><span class="line"><span class="meta">$</span> cd Python-2.7.13/</span><br><span class="line"><span class="meta">$</span> ./configure</span><br><span class="line"><span class="meta">$</span> make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>这个过程也会需要一段时间，如果中途报错，基本就是gcc的原因，先更新gcc(<code>yum -y install gcc</code>)再重新安装。默认会将python安装<code>/usr/local/bin/python2.7</code></p><h3 id="0x01-配置"><a href="#0x01-配置" class="headerlink" title="0x01 配置"></a>0x01 配置</h3><p>上述步骤完成后我们来看现在系统中python的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> /usr/local/bin/python2.7 -V</span><br><span class="line">Python 2.7.13</span><br><span class="line"><span class="meta">$</span> python -V</span><br><span class="line">Python 2.6.6</span><br></pre></td></tr></table></figure><p>可以看到我们系统默认的python还是老版本的，说明我们<code>/usr/bin/python</code>仍然指向2.6的python，所以接下来首先给旧版换个名称，然后将<code>/usr/bin/python</code>指向我们新版python的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> mv /usr/bin/python /usr/bin/python26</span><br><span class="line"><span class="meta">$</span> ln -s /usr/local/bin/python2.7 /usr/bin/python </span><br><span class="line"><span class="meta">$</span> python -V</span><br><span class="line">Python 2.7.13</span><br></pre></td></tr></table></figure><p>ok，还剩最后一步，修改yum的配置，因为yum用的是老版本的python，我们更新系统的python后导致yum所使用的python版本不符</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> vi /usr/bin/yum</span><br><span class="line"><span class="meta">#</span>!/usr/bin/python</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>看到没，yum使用的是系统的python，我们将其第一行改成<code>#!/usr/bin/python26</code>就ok了。</p><h3 id="PIP安装"><a href="#PIP安装" class="headerlink" title="PIP安装"></a>PIP安装</h3><p>至此我们python的更新已经完成了，接下来再来安装个pip，pip是python的包管理器，可以说pip之于python类似于npm之于node，可想而知其重要性。关于pip的安装，以下给出一个最实用的安装方式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> wget https://bootstrap.pypa.io/get-pip.py</span><br><span class="line"><span class="meta">$</span> python get-pip.py</span><br></pre></td></tr></table></figure><p>get-pip.py 会根据你的python版本自动安装pip及其依赖包（setuptools）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文本介绍如何在linux中将python更新到最新版本。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="devops" scheme="https://sidfate.github.io/categories/tech/devops/"/>
    
    
      <category term="linux" scheme="https://sidfate.github.io/tags/linux/"/>
    
      <category term="python" scheme="https://sidfate.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Linux 部署node服务</title>
    <link href="https://sidfate.github.io/2017/02/17/tech/devops/linux-node-server/"/>
    <id>https://sidfate.github.io/2017/02/17/tech/devops/linux-node-server/</id>
    <published>2017-02-17T07:01:56.000Z</published>
    <updated>2018-10-14T02:39:19.357Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Linux部署篇 - 如何在linux上不是express的node服务<br><a id="more"></a></p><h3 id="0x00-前提"><a href="#0x00-前提" class="headerlink" title="0x00 前提"></a>0x00 前提</h3><p>这篇文章主要讲的是linux系统下一个express的node项目的部署，express是一个web开发的node框架。</p><h3 id="0x01-过程"><a href="#0x01-过程" class="headerlink" title="0x01 过程"></a>0x01 过程</h3><p>部署工具推荐使用pm2，还有个是forever，但是相对而言pm2用起来更方便的，所以首先我们安装pm2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm install pm2 -g</span><br></pre></td></tr></table></figure><p>然后使用pm2创建进程，例如我们这里启动一个express项目，关于pm2的其他使用看<a href="">这里</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 start bin/www</span><br></pre></td></tr></table></figure><p>express默认监听端口是3000，现在你应该已经可以通过<code>http://yourdomain:3000</code>访问你的node项目了，如果还不行看<a href="/linux-firewall-open-port">这里</a>。我们最后还可以使用nginx服务器做代理，修改<code>nginx.conf</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream nodejs &#123; </span><br><span class="line">        server 127.0.0.1:3000; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name youdomain.com;</span><br><span class="line">        location / &#123; </span><br><span class="line">            proxy_pass http://nodejs;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在你应该已经可以直接通过<code>http://yourdomain</code>访问你的node项目了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux部署篇 - 如何在linux上不是express的node服务&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="devops" scheme="https://sidfate.github.io/categories/tech/devops/"/>
    
    
      <category term="linux" scheme="https://sidfate.github.io/tags/linux/"/>
    
      <category term="node" scheme="https://sidfate.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>Python urllib2多线程</title>
    <link href="https://sidfate.github.io/2017/01/21/tech/python/python-urllib2-threads/"/>
    <id>https://sidfate.github.io/2017/01/21/tech/python/python-urllib2-threads/</id>
    <published>2017-01-21T03:26:23.000Z</published>
    <updated>2018-10-12T10:57:31.525Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍怎么使用urllib2和thread让你的爬虫多线程运行。<br><a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock</span><br><span class="line"><span class="keyword">from</span> Queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fetcher</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, threads)</span>:</span></span><br><span class="line">        self.opener = urllib2.build_opener(urllib2.HTTPHandler)</span><br><span class="line">        self.lock = Lock()</span><br><span class="line">        self.q_req = Queue()</span><br><span class="line">        self.q_ans = Queue()</span><br><span class="line">        self.threads = threads</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(threads):</span><br><span class="line">            t = Thread(target=self.get_thread)</span><br><span class="line">            t.setDaemon(<span class="keyword">True</span>)</span><br><span class="line">            t.start()</span><br><span class="line">        self.running = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        self.q_req.join()</span><br><span class="line">        self.q_ans.join()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_task</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.q_req.qsize()+self.q_ans.qsize()+self.running</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, req)</span>:</span></span><br><span class="line">        self.q_req.put(req)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.q_ans.get()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_thread</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            req = self.q_req.get()</span><br><span class="line">            <span class="keyword">with</span> self.lock:</span><br><span class="line">                self.running += <span class="number">1</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                ans = self.opener.open(req).read()</span><br><span class="line">            <span class="keyword">except</span> Exception, what:</span><br><span class="line">                ans = <span class="string">''</span></span><br><span class="line">                <span class="keyword">print</span> what</span><br><span class="line">            self.q_ans.put((req, ans))</span><br><span class="line">            <span class="keyword">with</span> self.lock:</span><br><span class="line">                self.running -= <span class="number">1</span></span><br><span class="line">            self.q_req.task_done()</span><br><span class="line">            time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    links = [<span class="string">'http://www.verycd.com/topics/%d/'</span> % i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5420</span>, <span class="number">5430</span>)]</span><br><span class="line">    f = Fetcher(threads=<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> links:</span><br><span class="line">        f.push(url)</span><br><span class="line">    <span class="keyword">while</span> f.get_task():</span><br><span class="line">        url, content = f.pop()</span><br><span class="line">        <span class="keyword">print</span> url, len(content)</span><br></pre></td></tr></table></figure><blockquote><p>更多爬虫技巧请戳<a href="/spider">传送门</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍怎么使用urllib2和thread让你的爬虫多线程运行。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="python" scheme="https://sidfate.github.io/categories/tech/python/"/>
    
    
      <category term="python" scheme="https://sidfate.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Linux 搭建svn服务器</title>
    <link href="https://sidfate.github.io/2017/01/21/tech/devops/linux-svn-server/"/>
    <id>https://sidfate.github.io/2017/01/21/tech/devops/linux-svn-server/</id>
    <published>2017-01-21T01:40:23.000Z</published>
    <updated>2018-10-14T02:36:45.836Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍在linux搭建自己的svn服务器。<br><a id="more"></a></p><h3 id="0x00-开始"><a href="#0x00-开始" class="headerlink" title="0x00 开始"></a>0x00 开始</h3><ol><li><p>通过yum直接安装subversion</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> yum install subversion</span><br></pre></td></tr></table></figure></li><li><p>创建版本库。版本库是一个svn用来进行版本管理的控制中心，我们将/home/svn作为我们管理所有版本库的目录，然后在其中创建一个project的版本库。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> mkdir /home/svn</span><br><span class="line"><span class="meta">$</span> svnadmin create /home/svn/project</span><br></pre></td></tr></table></figure></li><li><p>修改版本库配置。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd /home/svn/project &amp;&amp; ls</span><br><span class="line">conf  db  format  hooks  locks  README.txt</span><br></pre></td></tr></table></figure><p> 创建完毕的版本库中存在conf，hooks，locks等目录和文件。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd conf/ &amp;&amp; ls</span><br><span class="line">authz  passwd  svnserve.conf</span><br></pre></td></tr></table></figure><p> 进入conf目录我们能看到3个配置文件：authz，passwd，svnserve.conf。authz是svn用户的权限配置文件，passwd是svn用户密码的配置文件，svnserve.conf是版本库的主配置文件。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> vi passwd</span><br></pre></td></tr></table></figure><p> 我们先修改passwd，在文件末尾添加一行表示添加一个用户。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[users]</span><br><span class="line">sidfate = sidfate</span><br></pre></td></tr></table></figure><p> 然后修改authz，在文件末尾添加我们刚刚创建的svn用户对根目录的权限设置，这里我们设置为rw（读写），这里的根目录指的是版本库的根目录。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[/]</span><br><span class="line">sidfate = rw</span><br></pre></td></tr></table></figure><p> 最后修改svnserve.conf，去除下面配置前的注释。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">anon-access = read</span><br><span class="line">auth-access = write</span><br><span class="line">password-db = passwd</span><br><span class="line">authz-db = authz</span><br></pre></td></tr></table></figure><p> 这里说明一下，网上的资料有的说讲<code>realm = My First Repository</code>这一行也去注释，实际测试没有必要，还有如果你在客户端尝试checkout时出现权限验证的错误可以将<code>authz-db = authz</code>这一行注释回去就可以了。</p></li><li><p>启动和关闭svn服务。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> svnserve –d –r /home/svn/project/</span><br></pre></td></tr></table></figure><p>-d指明以守护模式运行，-r指定根目录，还可以使用–listen-port=切换监听端口，默认端口为3690。关闭svn服务可以使用以下命令。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ps -ef | grep svnserve</span><br><span class="line">root      1452   871  0 15:44 pts/0    00:00:00 grep svnserve</span><br><span class="line">root     29508     1  0 Jan20 ?        00:00:00 svnserve -d -r /home/svn/project/</span><br><span class="line"><span class="meta">$</span> kill 29508</span><br></pre></td></tr></table></figure></li><li><p>本地与服务器数据同步。我们现在可以在客户端环境checkout到本地，windows环境下可以使用第三方工具TortoiseSVN，操作很方便，如果是linux客户端，我们可以使用checkout命令。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ svn checkout svn://myurl/project</span><br></pre></td></tr></table></figure><p> 这里有一个误区，没有接触过版本控制的人可能尝试了在本地添加一个文件并上传，然后发现在服务器上找不到上传的文件。实际上版本控制记录了你的提交，你可以在本地的另一处checkout该项目发现你上传的文件已经存在了。在服务器上其实也是同一个道理，你在服务器上同样需要checkout一份代码，我们之前所作的其实就是创建了一个文件控制的中枢，你提交文件到svn服务器，然后在你的服务器上更新代码。也许你会觉得这个步骤繁琐了，别担心，我们可以使用svn的post-commit来自动同步代码的更新，来达到你本地的代码提交后服务器上的代码同步更新的功能。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd /home/svn/project/hooks </span><br><span class="line"><span class="meta">$</span> cp post-commit.tmpl post-commit</span><br><span class="line"><span class="meta">$</span> vi post-commit</span><br></pre></td></tr></table></figure><p> 找到你版本库的hooks目录，拷贝post-commit.tmpl为post-commit，然后编辑该文件，添加以下内容。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REPOS="$1"</span><br><span class="line">REV="$2"</span><br><span class="line">cd /home/wwwroot/project/ &amp;&amp; /usr/bin/svn update --username sidfate --password sidfate</span><br></pre></td></tr></table></figure><p> 注意第三条语句，/home/wwwroot/project/就是我放在服务器上的代码目录，这里的操作就是每次有svn提交后进入该目录然后更新代码。还要注意的是，请给予post-commit足够的权限，不然提交的时候会提示该文件出错。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> chmod 770 post-commit</span><br></pre></td></tr></table></figure><p> 仍然需要注意的一个问题是如果你的svn目录中存在中文命名的文件，那么可能会出现以下类似的错误:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn: Error converting entry in directory &apos;.&apos; to UTF-8</span><br></pre></td></tr></table></figure><p> 这个时候你需要在之前编写的post-commit文件里的命令前加上一段设置编码。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LANG=en_US.UTF-8 &amp;&amp; cd /home/wwwroot/project/ &amp;&amp; /usr/bin/svn update --username sidfate --password sidfate</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍在linux搭建自己的svn服务器。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="devops" scheme="https://sidfate.github.io/categories/tech/devops/"/>
    
    
      <category term="linux" scheme="https://sidfate.github.io/tags/linux/"/>
    
      <category term="svn" scheme="https://sidfate.github.io/tags/svn/"/>
    
  </entry>
  
  <entry>
    <title>Python zip暴力破解</title>
    <link href="https://sidfate.github.io/2016/12/10/tech/python/python-zip-crack/"/>
    <id>https://sidfate.github.io/2016/12/10/tech/python/python-zip-crack/</id>
    <published>2016-12-10T06:34:00.000Z</published>
    <updated>2018-10-14T01:51:54.621Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>网上下到带有密码的zip文件，但是又没有给出密码，着实头疼，不如自动动手用python写一个zip暴力破解程序。<br><a id="more"></a></p><blockquote><p>阅读文本前推荐您先浏览之前的文章：<a href="/tech/python/python-password-dict">Python 创建黑客字典</a></p></blockquote><h3 id="0x00-前提"><a href="#0x00-前提" class="headerlink" title="0x00 前提"></a>0x00 前提</h3><ol><li><p>python提供了对zip文件的操作库zipfile。其中 ZipFile 类中的 extractall() 方法提供了 pwd 参数作为 zip 文件的密码。<a href="https://docs.python.org/2.7/library/zipfile.html" target="_blank" rel="noopener">更多关于 zipfile</a></p></li><li><p>python 中的 optparse 模块可以用来处理命令行参数。其主要使用流程：首先，必须 import OptionParser 类，创建一个 OptionParser 对象，然后，使用 add_option 来定义命令行参数，每个命令行参数就是由参数名字符串和参数属性组成的。最后，一旦你已经定义好了所有的命令行参数，调用 parse_args() 来解析程序的命令行。<a href="https://docs.python.org/2/library/optparse.html" target="_blank" rel="noopener">更多关于 optparse</a></p></li></ol><p>作为测试，我们将我们写一个名为 unzip.py 的脚本来破解密码，在它的同级目录下存在测试文件 test.zip 和字典文件 dict.txt（<a href="/tech/python/python-password-dict">关于字典文件的创建</a>），其中 zip 文件的密码为 123456 。</p><h3 id="0x01-代码"><a href="#0x01-代码" class="headerlink" title="0x01 代码"></a>0x01 代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> optparse</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extractFile</span><span class="params">(zFile, password)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        zFile.extractall(pwd=password)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'[+] Found password '</span> + password + <span class="string">'\n'</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    parser = optparse.OptionParser(<span class="string">"usage%prog -f &lt;zipfile&gt; -d &lt;dictionary&gt;"</span>)</span><br><span class="line">    parser.add_option(<span class="string">'-f'</span>, dest=<span class="string">'zname'</span>, type=<span class="string">'string'</span>, \</span><br><span class="line">                      help=<span class="string">'specify zipfile file'</span>)</span><br><span class="line">    parser.add_option(<span class="string">'-d'</span>, dest=<span class="string">'dname'</span>, type=<span class="string">'string'</span>, \</span><br><span class="line">                      help=<span class="string">'specify dictionary file'</span>)</span><br><span class="line">    (options, args) = parser.parse_args()</span><br><span class="line">    <span class="keyword">if</span> (options.zname == <span class="keyword">None</span>) | (options.dname == <span class="keyword">None</span>):</span><br><span class="line">        <span class="keyword">print</span> parser.usage</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        zname = options.zname</span><br><span class="line">        dname = options.dname</span><br><span class="line">    zFile = zipfile.ZipFile(zname)</span><br><span class="line">    passFile = open(dname)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> passFile.readlines():</span><br><span class="line">        password = line.strip(<span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">if</span> extractFile(zFile, password):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网上下到带有密码的zip文件，但是又没有给出密码，着实头疼，不如自动动手用python写一个zip暴力破解程序。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="python" scheme="https://sidfate.github.io/categories/tech/python/"/>
    
    
      <category term="python" scheme="https://sidfate.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python 创建黑客字典</title>
    <link href="https://sidfate.github.io/2016/09/29/tech/python/python-password-dict/"/>
    <id>https://sidfate.github.io/2016/09/29/tech/python/python-password-dict/</id>
    <published>2016-09-29T09:56:00.000Z</published>
    <updated>2018-10-14T01:46:50.953Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文告诉你什么是黑客字典，如何用python轻松的生成黑客常用的密码字典。<br><a id="more"></a></p><h3 id="0x00-前提"><a href="#0x00-前提" class="headerlink" title="0x00 前提"></a>0x00 前提</h3><p>黑客字典，其实就是一些常用的字符集合，往往包含了大量的刻意生成的字符串组合，用来暴力破解某些密码。我们可以用python，只书写几行代码，就可以迭代生成大量我们需要的字符串组合。</p><p>首先简单的介绍下用到的2个库：<strong>string</strong> 和 <strong>itertools</strong>。</p><ul><li>介绍 <strong>string</strong> 模块中几个有用的全局变量：<ul><li>string.letters: <code>abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</code></li><li>string.printable: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">  - string.lowercase: `abcdefghijklmnopqrstuvwxyz`</span><br><span class="line">  - string.uppercase: `ABCDEFGHIJKLMNOPQRSTUVWXYZ`</span><br><span class="line"></span><br><span class="line">* **itertools** 是python的循环器库。循环器是对象的容器，包含有多个对象。`itertools.product()` 的结果为笛卡尔积，相当于一个嵌套循环。`itertools.chain()`将多个循环器结合成单个循环器。[更多关于 itertools](https://docs.python.org/2/library/itertools.html)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 0x01 代码</span><br><span class="line">```python</span><br><span class="line"># !/usr/bin/env python</span><br><span class="line"># coding:utf-8</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">import string</span><br><span class="line">import itertools</span><br><span class="line"></span><br><span class="line">def get_strings():</span><br><span class="line">    chars = string.printable[:10]</span><br><span class="line">    strings = []</span><br><span class="line">    for i in xrange(min, max + 1):</span><br><span class="line">        strings.append((itertools.product(chars, repeat=i),))</span><br><span class="line">    return itertools.chain(*strings)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def make_dict(file, list_str):</span><br><span class="line">    f = open(file, &apos;a&apos;)</span><br><span class="line">    for x in list_str:</span><br><span class="line">        print x</span><br><span class="line">        for y in x:</span><br><span class="line">            f.write(&quot;&quot;.join(y))</span><br><span class="line">            f.write(&apos;\n&apos;)</span><br><span class="line">    f.close()</span><br><span class="line">    print &apos;Done&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    if len(sys.argv) == 4:</span><br><span class="line">        try:</span><br><span class="line">            min = int(sys.argv[1])</span><br><span class="line">            max = int(sys.argv[2])</span><br><span class="line">        except:</span><br><span class="line">            print &quot;wrong&quot;</span><br><span class="line">            sys.exit(0)</span><br><span class="line"></span><br><span class="line">        if min &lt;= max:</span><br><span class="line">            list_str = get_strings()</span><br><span class="line">            file = str(sys.argv[3])</span><br><span class="line">            make_dict(file, list_str)</span><br><span class="line">            sys.exit(0)</span><br><span class="line">    else:</span><br><span class="line">        print &quot;missing some argvs&quot;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="0x02-结果"><a href="#0x02-结果" class="headerlink" title="0x02 结果"></a>0x02 结果</h3><p>这里我们的脚本文件为<code>dict.py</code>，后面的参数分别为密码的最小长度、密码的最大长度以及保存的字典文件名。上面的例子运行成功后会在脚本文件同级目录下生成一个<code>dict.txt</code>的字典文件，其中包含6位随机纯数字的所有组合。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文告诉你什么是黑客字典，如何用python轻松的生成黑客常用的密码字典。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="python" scheme="https://sidfate.github.io/categories/tech/python/"/>
    
    
      <category term="python" scheme="https://sidfate.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>ModernPHP 密码与时间相关</title>
    <link href="https://sidfate.github.io/2016/09/28/tech/php/modernphp-password-date/"/>
    <id>https://sidfate.github.io/2016/09/28/tech/php/modernphp-password-date/</id>
    <published>2016-09-27T22:15:00.000Z</published>
    <updated>2018-10-16T10:03:57.838Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>用php自带的函数生产密码，验证密码；php时间和日期函数的使用。<br><a id="more"></a></p><h3 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h3><p><code>password_hash()</code>函数生成密码的hash值。该函数的第一个参数是纯文本密码，第二个参数选择所用的hash算法，目前支持的算法有<code>PASSWORD_DEFAULT</code>（采用bcrypt算法，PHP5.5.0默认）和<code>PASSWORD_BCRYPT</code>（使用 CRYPT_BLOWFISH 算法），第三参数指定所有的选项，选项有salt（手动指定的盐，7.0已被废弃）和cost（工作因子）。工作因子的默认值是10。</p><p><code>password_verify()</code>函数可以验证密码和指定的哈希值，验证成功返回true，失败返回false。</p><p><code>password_needs_rehash()</code>函数验证给定的hash值是否实现了提供的算法和选项。该函数一个参数是给定的hash值，第二个参数选择hash算法，第三参数是选项。</p><h3 id="日期与时间"><a href="#日期与时间" class="headerlink" title="日期与时间"></a>日期与时间</h3><p><strong>DateTime类</strong></p><p>DateTime类提供了一个面对对象的接口，用于管理日期和时间。一个DateTime实例表示了一个具体的日期和时间。通过DateTime类可以简单的创建DateTime实例。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$datatime = <span class="keyword">new</span> DateTime();</span><br><span class="line">$datetime = <span class="keyword">new</span> DateTime(<span class="string">'2016-09-27 10:05 AM'</span>);</span><br></pre></td></tr></table></figure><p>DateTime类的构造函数可以不传任何参数，表示获取的是当前日期和时间的实例，也可以传递一个表示日期和时间的字符串指定其他的日期和时间，该字符串必须符合<a href="http://php.net/manual/zh/datetime.formats.php" target="_blank" rel="noopener">特定的格式</a>。</p><p>当我们需要处理各种特殊格式的日期和时间时，可以使用<code>DateTime::createFromFormat()</code>静态方法，针对自定义格式创建DateTime实例。该方法的第一个参数是表示日期和时间格式的字符串，第二个参数是使用指定格式的日期和时间的字符串。<code>DateTime::createFromFormat()</code>静态方法使用的日期和时间字符串的格式和date()函数一样，具体的参照看<a href="http://php.net/manual/zh/datetime.createfromformat.php" target="_blank" rel="noopener">这里</a>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$datetime = DateTime::createFromFormat(<span class="string">'M j, Y H:i:s'</span>, <span class="string">'Jan 2, 2016 15:03:24'</span>);</span><br></pre></td></tr></table></figure><p><strong>DateInterval类</strong></p><p>DateInterval实例表示长度固定的时间段（例如“两天”），或者相对而言的时间段（例如“昨天”）。DateInterval实例用于修改DateTime实例。例如DateTime类提供了<code>add()</code>和<code>sub()</code>两个方法，这两个方法的参数都是DateInterval实例，指定要添加到DateTime实例的时间量，或要从DateTime实例中减去的时间量。</p><p>DateInterval类构造方法的参数是一个表示间隔规格的字符串。间隔规格是一个以“P”开头的字符串，后面接一个整数，最后是一个周期标识符，限定前面的整数。有效的周期标识符有：</p><ul><li>Y（年）</li><li>M（月）</li><li>D（日）</li><li>W（周）</li><li>H（时）</li><li>M（分）</li><li>S（秒）</li></ul><p>间隔规格中既可以有日期也可以有时间，如果两者都有，需要在两者中间加上“T”。例如“P2D”表示2天，<code>P2DT1H2M</code>表示2天1小时2分钟。下面一个例子通过给DateTime的<code>add()</code>方法传递了DateInterval实例来修改DateTime实例表示的日期。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$datetime = <span class="keyword">new</span> DateTime(<span class="string">'2014-04-27 5:03 AM'</span>);</span><br><span class="line">$interval = <span class="keyword">new</span> DateInterval(<span class="string">'P2W'</span>);</span><br><span class="line">$datetime-&gt;add($interval);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output: 2014-05-11 05:03:00</span></span><br><span class="line"><span class="keyword">echo</span> $datetime-&gt;format(<span class="string">'Y-m-d H:i:s'</span>);</span><br></pre></td></tr></table></figure><p><strong>DateTimeZone类</strong></p><p>DateTime类构造方法还存在第二个参数，为一个DateTimeZone实例，表示的是时区。DateTimeZone实例可以有DateTimeZone类构造方法生成，需要传递给构造方法一个<a href="http://php.net/manual/zh/timezones.php" target="_blank" rel="noopener">有效的时区标志</a>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$timezone = <span class="keyword">new</span> DateTimeZone(<span class="string">'Asia/Shanghai'</span>);</span><br><span class="line">$datetime = <span class="keyword">new</span> DateTime(<span class="string">'2014-04-27 5:03 AM'</span>, $timezone);</span><br><span class="line">$datetime-&gt;setTimezone(<span class="keyword">new</span> DateTimeZone(<span class="string">'Asia/Tokyo'</span>));</span><br></pre></td></tr></table></figure><p><strong>DatePeriod类</strong><br>当我们需要迭代处理相同间隔的一系列日期和时间时，我们可以使用DatePeriod类。DatePeriod类的构造方法必须提供3个参数：</p><ul><li>一个DateTime实例，表示开始的日期和时间</li><li>一个DateInterval实例，表示时间间隔</li><li>一个整数，表示迭代的次数</li></ul><p>DatePeriod的实例是一个迭代器每次迭代都会产生一个DateTime实例。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$datetime = <span class="keyword">new</span> DateTime(<span class="string">'2014-04-27 5:03 AM'</span>);</span><br><span class="line">$interval = <span class="keyword">new</span> DateInterval(<span class="string">'P2W'</span>);</span><br><span class="line">$period = <span class="keyword">new</span> DatePeriod($datetime, $interval, <span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">foreach</span> ($period <span class="keyword">as</span> $next) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $next-&gt;format(<span class="string">'Y-m-d H:i:s'</span>).PHP_EOL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ModernPHP 系列全集：<a href="/modernphp/">传送门</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用php自带的函数生产密码，验证密码；php时间和日期函数的使用。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="php" scheme="https://sidfate.github.io/categories/tech/php/"/>
    
    
      <category term="php" scheme="https://sidfate.github.io/tags/php/"/>
    
      <category term="modernphp" scheme="https://sidfate.github.io/tags/modernphp/"/>
    
  </entry>
  
  <entry>
    <title>ModernPHP PDO</title>
    <link href="https://sidfate.github.io/2016/09/23/tech/php/modern-pdo/"/>
    <id>https://sidfate.github.io/2016/09/23/tech/php/modern-pdo/</id>
    <published>2016-09-22T20:16:00.000Z</published>
    <updated>2018-10-16T10:05:50.612Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>现代化的php框架基本都继承了PDO，让我们来看看PDO的来源，以及它原生的使用方式。<br><a id="more"></a></p><h3 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h3><p>PDO（PHP Data Objects，PHP数据对象）是一系列的PHP类，抽象了不同数据库的具体实现，提供了统一的接口来操作不同的数据库。</p><h3 id="0x01-数据库连接"><a href="#0x01-数据库连接" class="headerlink" title="0x01 数据库连接"></a>0x01 数据库连接</h3><p>PDO类的构造方法的第一个参数为字符串，指定了DSN（Data Source Name，数据源名称），提供数据连接的详细信息。DSN的开头是数据库驱动器的名称（例如mysql或sqlite），然后接一个”:”号，后面是其他连接信息（主机名、端口号，数据库名和字符集等），更多内容可以查看<a href="http://php.net/manual/en/pdo.drivers.php" target="_blank" rel="noopener">pdo.drivers</a>。PDO类构造方法的第二个参数和第三个参数分别是数据库的用户名和密码。举一个使用的列子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    $pdo = <span class="keyword">new</span> PDO(</span><br><span class="line"><span class="string">'mysql:host=127.0.0.1;dbname=books;port=3306;charset=utf8'</span>,</span><br><span class="line">USERNAME,</span><br><span class="line">PASSWORD</span><br><span class="line">);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PDOException $e) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Database connection failed"</span>;</span><br><span class="line">    <span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们不建议使用硬编码的方式写入数据库的连接信息，这样一旦数据库连接出错，很可能就暴露给用户你的PHP代码。所以我们更建议将数据库连接信息写入一个配置文件，然后在主程序中引入配置文件。下面给出一个配置文件的样例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$setting = [</span><br><span class="line"><span class="string">'host'</span>=&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line"><span class="string">'port'</span>=&gt; <span class="number">3306</span>,</span><br><span class="line"><span class="string">'dbname'</span>=&gt; <span class="string">'users'</span>,</span><br><span class="line"><span class="string">'username'</span>=&gt; <span class="string">'USERNAME'</span>,</span><br><span class="line"><span class="string">'password'</span>=&gt; <span class="string">'PASSWORD'</span>,</span><br><span class="line"><span class="string">'charset'</span>=&gt; <span class="string">'utf8'</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="预处理语句"><a href="#预处理语句" class="headerlink" title="预处理语句"></a>预处理语句</h3><p>在SQL语句中使用用户输入的数据一定要过滤，PDO通过预处理语句和参数绑定将过滤输入这项操作变得简单很多。</p><p>预处理语句是<code>PDOStatement</code>的实例。一般可以使用PDO实例的<code>prepare()</code>方法获取预处理语句对象。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">$sql = <span class="string">'SELECT * FROM users WHERE email=:email'</span>;</span><br><span class="line">$statement = $pdo-&gt;prepare($sql);</span><br><span class="line"></span><br><span class="line">$email = filter_input(INPUT_GET, <span class="string">'email'</span>);</span><br><span class="line">$statement-&gt;bindParam(<span class="string">':email'</span>, $email);</span><br></pre></td></tr></table></figure><p>在上面的SQL语句中，<code>:email</code>是具名占位符，可以在<code>$statement</code>实例中通过<code>bindValue()</code>方法绑定为我们需要的值。预处理语句可以自动过滤<code>$email</code>的值，防止SQL注入的发生。在一个SQL语句中可以存在多个多个具名占位符，<code>bindParam()</code>方法提供了第三个参数，指定需要绑定值的数据类型（例如<code>PDO::PARAM_INT</code>，<a href="http://php.net/manual/en/pdo.constants.php" target="_blank" rel="noopener">更多常量</a>），默认的数据类型是字符串。</p><h3 id="查询结果"><a href="#查询结果" class="headerlink" title="查询结果"></a>查询结果</h3><p>有了预处理语句之后，就可以在数据库中执行SQL查询操作了。调用预处理对象的<code>execute()</code>方法后会使用绑定的所有数据执行SQL语句。如果执行的操作是UPDATE，INSERT或DELETE，<code>execute()</code>方法后工作就结束了（当然还可以通过该函数返回TRUE或FALSE判断操作成功与否）。但是如果是SELECT操作，我们还要去获取返回的数据，这时可以通过预处理对象的<code>fetch()</code>，<code>fetchAll()</code>，<code>fetchColumn()</code>或<code>fetchObject()</code>方法获取查询结果。</p><p><code>fetch()</code>用于获取结果数据集的一行，这个方法适用于迭代大型的数据集。<code>fetchAll()</code>可以获取整个数据集，<code>fetch()</code>和<code>fetchAll()</code>的第一个参数为PDO类的<a href="http://php.net/manual/en/pdostatement.fetch.php" target="_blank" rel="noopener">返回方式常量</a>，决定了如何返回查询结果，常用的常量有：</p><ul><li>PDO::FETCH_ASSOC：返回一个以数据库列名为键的关联数组。</li><li>PDO::FETCH_NUM：返回一个以数字为键的关联数组。</li><li>PDO::FETCH_OBJ：返回一个属性名为数据库列名的对象。</li><li>PDO::FETCH_BOTH：返回一个键既包含数据库列名也包含数组的关联数组。</li></ul><p>举一个使用的例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$sql = <span class="string">'SELECT id, name FROM users WHERE email=:email'</span>;</span><br><span class="line">$statement = $pdo-&gt;prepare($sql);</span><br><span class="line"></span><br><span class="line">$email = filter_input(INPUT_GET, <span class="string">'email'</span>);</span><br><span class="line">$statement-&gt;bindParam(<span class="string">':email'</span>, $email);</span><br><span class="line">$statement-&gt;execute();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (($result = $statement-&gt;fetch(PDO::FETCH_ASSOC)) != <span class="keyword">false</span>) &#123;</span><br><span class="line"><span class="keyword">echo</span> $result[<span class="string">'name'</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是指把一系列数据库语句当成单个逻辑单元来处理。也就是说，事务中的一系列sql语句要么都执行成功，要么根本不执行，也就是说事务具有原子性。事务的原子性也保证了数据的一致性，安全性和持久性。事务还能提升性能，因为它实际上是把多个查询排成队列，一次全部执行。</p><p>PDO支持事务，而且使用方便，你只要把构建和执行sql的操作放在PDO实例的<code>beginTransaction()</code>和<code>commit()</code>中。<code>beginTransaction()</code>方法的作用是把后续生成的sql语句排入队列，<code>commit()</code>方法执行原子事务队列中的sql语句。</p><p>下面演示一个未使用事务的例子，其操作是从A账户的钱转入B账户：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'../setting.php'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">$pdo = <span class="keyword">new</span> PDO(</span><br><span class="line">sprintf(</span><br><span class="line"><span class="string">'mysql:host=%s;dbname=%s;port=%s;charset=%s'</span>,</span><br><span class="line">$setting[<span class="string">'host'</span>],</span><br><span class="line">$setting[<span class="string">'dbname'</span>],</span><br><span class="line">$setting[<span class="string">'port'</span>],</span><br><span class="line">$setting[<span class="string">'charset'</span>]</span><br><span class="line">),</span><br><span class="line">$setting[<span class="string">'username'</span>],</span><br><span class="line">$setting[<span class="string">'password'</span>]</span><br><span class="line">);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PDOException $e) &#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Database connection failed"</span>;</span><br><span class="line"><span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$stmtSub = $pdo-&gt;prepare(<span class="string">'</span></span><br><span class="line"><span class="string">UPDATE accounts </span></span><br><span class="line"><span class="string">SET amount = amount - :amount</span></span><br><span class="line"><span class="string">WHERE name = :name</span></span><br><span class="line"><span class="string">'</span>);</span><br><span class="line">$stmtAdd = $pdo-&gt;prepare(<span class="string">'</span></span><br><span class="line"><span class="string">UPDATE accounts </span></span><br><span class="line"><span class="string">SET amount = amount + :amount</span></span><br><span class="line"><span class="string">WHERE name = :name</span></span><br><span class="line"><span class="string">'</span>);</span><br><span class="line"></span><br><span class="line">$fromAccount = <span class="string">'A'</span>;</span><br><span class="line">$toAccount = <span class="string">'B'</span>;</span><br><span class="line">$money = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从A账户取钱</span></span><br><span class="line">$stmtSub-&gt;bindParam(<span class="string">':amount'</span>, $money);</span><br><span class="line">$stmtSub-&gt;bindParam(<span class="string">':name'</span>, $fromAccount);</span><br><span class="line">$stmtSub-&gt;execute();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 钱存入B账户</span></span><br><span class="line">$stmtAdd-&gt;bindParam(<span class="string">':amount'</span>, $money);</span><br><span class="line">$stmtAdd-&gt;bindParam(<span class="string">':name'</span>, $toAccount);</span><br><span class="line">$stmtAdd-&gt;execute();</span><br></pre></td></tr></table></figure><p>这里有一个问题是，当从A账户取钱的操作成功后，发生了一些不可抗拒的错误，导致了后面的把钱加到B账户的操作没有完成，那么这50元就凭空消失了，这显然是不合理的。使用事务我们可以解决这样的问题。下面是使用事务的方式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 开始事务</span></span><br><span class="line">$pdo-&gt;beginTransaction();</span><br><span class="line"></span><br><span class="line">$fromAccount = <span class="string">'jack'</span>;</span><br><span class="line">$toAccount = <span class="string">'rose'</span>;</span><br><span class="line">$money = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从A账户取钱</span></span><br><span class="line">$stmtSub-&gt;bindParam(<span class="string">':amount'</span>, $money);</span><br><span class="line">$stmtSub-&gt;bindParam(<span class="string">':name'</span>, $fromAccount);</span><br><span class="line">$stmtSub-&gt;execute();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 钱存入B账户</span></span><br><span class="line">$stmtAdd-&gt;bindParam(<span class="string">':amount'</span>, $money);</span><br><span class="line">$stmtAdd-&gt;bindParam(<span class="string">':name'</span>, $toAccount);</span><br><span class="line">$stmtAdd-&gt;execute();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交事务</span></span><br><span class="line">$pdo-&gt;commit();</span><br></pre></td></tr></table></figure><blockquote><p>ModernPHP 系列全集：<a href="/modernphp/">传送门</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现代化的php框架基本都继承了PDO，让我们来看看PDO的来源，以及它原生的使用方式。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="php" scheme="https://sidfate.github.io/categories/tech/php/"/>
    
    
      <category term="php" scheme="https://sidfate.github.io/tags/php/"/>
    
      <category term="modernphp" scheme="https://sidfate.github.io/tags/modernphp/"/>
    
  </entry>
  
  <entry>
    <title>ModernPHP 过滤、验证和转义</title>
    <link href="https://sidfate.github.io/2016/09/23/tech/php/modernphp-filter-verification-escape/"/>
    <id>https://sidfate.github.io/2016/09/23/tech/php/modernphp-filter-verification-escape/</id>
    <published>2016-09-22T18:43:00.000Z</published>
    <updated>2018-10-16T09:59:05.218Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>php自带有验证过滤方法，可以满足大部分的使用场景，不用再自己写正则了。<br><a id="more"></a></p><h3 id="html"><a href="#html" class="headerlink" title="html"></a>html</h3><p>使用<code>htmlentities()</code>函数过滤html输入，它会将字符转换成html实体。但是在默认情况下，<code>htmlentities()</code>函数不会转义单引号，也检测不出输入字符串的字符集。所以正确的使用方式是额外传入2个参数，即第一个参数是输入的字符串，第二个参数设为ENT_QUOTES常量，转义单引号，第三个参数设为输入字符串的字符集。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$str = <span class="string">"A 'quote' is &lt;b&gt;bold&lt;/b&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Outputs: A 'quote' is &amp;lt;b&amp;gt;bold&amp;lt;/b&amp;gt;</span></span><br><span class="line"><span class="keyword">echo</span> htmlentities($str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Outputs: A &amp;#039;quote&amp;#039; is &amp;lt;b&amp;gt;bold&amp;lt;/b&amp;gt;</span></span><br><span class="line"><span class="keyword">echo</span> htmlentities($str, ENT_QUOTES);</span><br></pre></td></tr></table></figure><h3 id="SQL查询"><a href="#SQL查询" class="headerlink" title="SQL查询"></a>SQL查询</h3><p>一个低级而常见的错误即是将原始输入数据直接拼接成SQL查询语句，这将导致程序产生<a href="http://blog.jobbole.com/67875/" target="_blank" rel="noopener">SQL注入漏洞</a>。下面将描述一个错误的例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">$sql = sprintf( </span><br><span class="line">  <span class="string">'UPDATE users SET passwd='</span>%s<span class="string">' WHERE id=%s'</span>, </span><br><span class="line">  $_POST[<span class="string">'passwd'</span>], </span><br><span class="line">  $_GET[<span class="string">'id'</span>] );</span><br></pre></td></tr></table></figure><p>这时，假如用户构造恶意的输入数据，例如<code>passwd=abc&quot;;--</code>，所有用户的密码都将会被设置为abc，很多数据库把<code>--</code>当做注释符。使用PDO预处理语句可以防止这种情况的发生，关于PDO预处理在后面的文章中将讲到。</p><h3 id="用户资料信息"><a href="#用户资料信息" class="headerlink" title="用户资料信息"></a>用户资料信息</h3><p>PHP提供了<code>filter_var()</code>和<code>filter_input()</code>函数来过滤不同类型的输入：电子邮件地址，URL编码字符串，整数，浮点数，HTML字符，URL和特定范围内的ASCII字符。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="comment">// Outputs: string(15) &amp;quot;bob@example.com&amp;quot; </span></span><br><span class="line">var_dump(filter_var(<span class="string">'bob@example.com'</span>, FILTER_VALIDATE_EMAIL)); </span><br><span class="line"><span class="comment">// Outputs: bool(false) </span></span><br><span class="line">var_dump(filter_var(<span class="string">'http://example.com'</span>, FILTER_VALIDATE_URL, FILTER_FLAG_PATH_REQUIRED));</span><br></pre></td></tr></table></figure><p><code>filter_var()</code>函数如果验证成功，会返回验证的值，如果验证失败，返回false。</p><blockquote><p>ModernPHP 系列全集：<a href="/modernphp/">传送门</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;php自带有验证过滤方法，可以满足大部分的使用场景，不用再自己写正则了。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="php" scheme="https://sidfate.github.io/categories/tech/php/"/>
    
    
      <category term="php" scheme="https://sidfate.github.io/tags/php/"/>
    
      <category term="modernphp" scheme="https://sidfate.github.io/tags/modernphp/"/>
    
  </entry>
  
  <entry>
    <title>ModernPHP PSR</title>
    <link href="https://sidfate.github.io/2016/09/13/tech/php/modernphp-psr/"/>
    <id>https://sidfate.github.io/2016/09/13/tech/php/modernphp-psr/</id>
    <published>2016-09-13T13:44:00.000Z</published>
    <updated>2018-10-16T10:05:34.379Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>PSR是PHP Standards Recommendation（PHP推荐标准），规定了一系列PHP程序的标准方案。<br><a id="more"></a></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>PSR是PHP Standards Recommendation（PHP推荐标准）的简称。到目前为止，有四个被广泛认同的标准：</p><ul><li>PSR-1：<a href="http://www.php-fig.org/psr/psr-1/" target="_blank" rel="noopener">基本代码风格</a></li><li>PSR-2：<a href="http://www.php-fig.org/psr/psr-2/" target="_blank" rel="noopener">代码风格指南</a></li><li>PSR-3：<a href="http://www.php-fig.org/psr/psr-3/" target="_blank" rel="noopener">日志记录器接口</a></li><li>PSR-4：<a href="http://www.php-fig.org/psr/psr-4/" target="_blank" rel="noopener">自动加载</a></li></ul><p>也许你还见过PSR-0（自动加载标准），PHP-FIG废弃了该推荐规范，用PSR-4替代了它。</p><h3 id="PSR-1"><a href="#PSR-1" class="headerlink" title="PSR-1"></a>PSR-1</h3><p><strong>php标签</strong></p><p>必须把PHP代码放在&lt;?php ?&gt;或&lt;? ?&gt;标签中。</p><p><strong>编码</strong></p><p>必须使用UTF-8 without BOM的编码。</p><p><strong>目的性</strong></p><p>一个PHP文件可以定义符号（类，性状，函数和常量等），或者执行副作用的操作（例如，生成结果或者处理数据），但是不能同时做这两件事。</p><p><strong>自动加载</strong></p><p>PHP命名空间和类必须遵守PSR-4自动加载器标准。</p><p><strong>类名</strong></p><p>PHP类名必须使用首字母大写的驼峰命名方式，比如UserData。</p><p><strong>常量名</strong></p><p>PHP常量的名称必须全部使用大写字母，必要的话可以使用下划线连接单词，例如PAGE_SIZE。</p><p><strong>方法名</strong></p><p>PHP方法名必须使用首字母小写的驼峰命名方式，比如getUserInfo。</p><h3 id="PSR-2"><a href="#PSR-2" class="headerlink" title="PSR-2"></a>PSR-2</h3><p>PSR-2相对于PSR-1的代码风格更加严格。</p><p><strong>贯彻PSR-1</strong></p><p>使用PSR-2代码风格之前必须先贯彻PSR-1。</p><p><strong>缩进</strong></p><p>这个话题就很热门了，代码的缩进一直分为两个阵营：tab键阵营，多空格阵营。《硅谷》中有一集男女两名程序员正一边编程一边约会，小伙子忍受不了姑娘使用空格键缩进，认为Tab键更节省文件体积，最后愤然离去，声称绝对不会和用空格键缩进的人滚床单，以免孩子面临艰难的人生抉择……可见这个问题在程序员中是比较突出和常见的，PSR-2推荐规范要求PHP代码使用4个空格的缩进。</p><p><strong>文件代码行</strong></p><p>PHP文件必须使用UNIX风格的换行符（LF），最后要有一个空行，而且不能使用PHP关闭标签?&gt;。PHP每行代码不能超过80个字符，至少不能超过120个字符。每行末尾不能有空格。</p><p><strong>关键字</strong></p><p>PHP关键字应该使用小写字母。</p><p><strong>命名空间</strong></p><p>每个命名空间声明语句后必须跟着一个空行，类似的，使用use导入命名空间的语句后面也要加一个空行。下面是一个示例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;php</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">My</span>\<span class="title">Component</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">use</span> <span class="title">Symfony</span>\<span class="title">Components</span>\<span class="title">HttpFoundation</span>\<span class="title">Request</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Symfony</span>\<span class="title">Components</span>\<span class="title">HttpFoundation</span>\<span class="title">Response</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PSR-2要求类定义体的起始括号应该在类名之后新起一行写，结束括号必须在定义体后新起一行，就像上面那个例子一样。如果类扩展其他类或者实现接口，extends和implements关键字必须和类名同一行。</p><p><strong>方法</strong></p><p>方法定义体的括号位置应该可类定义的括号一样。方法的参数需要注意：起始圆括号之后和结束圆括号之前都没有空格，方法的每个参数后面都有一个逗号和空格。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;php</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Project</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">($id = <span class="number">1</span>, $name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可见性</strong></p><p>类中的每个属性和方法都要声明可见性，即public、protected或者private，来决定类的内部和外部如何访问这些属性和方法。请不要再对属性使用var关键字，在私有方法前加下划线。如果雷属性或方法声明为abstract或final，这两个限定符必须放在可见性关键字之前。static限定符应该放在可见性关键字之后。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Project</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> $startCount = <span class="string">'1.0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span>::$startCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>控制结构</strong></p><p>所有控制结构关键字后面都要有一个空格。控制结构关键字包括：if、elseif、else、switch、case、while、do while、for、foreach、try和catch。如果控制结构关键字后面有一对圆括号，起始圆括号之后和结束圆括号之前都没有空格。与类和方法的定义体不同，空间结构关键字后面的起始括号应该和控制结构关键字在同一行。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$num = <span class="number">0</span>;</span><br><span class="line">$flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($flag === <span class="keyword">false</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> ($num &amp;lt; <span class="number">10</span>) &#123;</span><br><span class="line">        $num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PSR-3"><a href="#PSR-3" class="headerlink" title="PSR-3"></a>PSR-3</h3><p>这个推荐规范讲的是一个接口，规定PHP日志记录器组件可以实现的方法。</p><p>符合PSR-3推荐规范的PHP日志记录，必须包含一个实现<code>Psr\Log\LoggerInterface</code>接口的PHP类。PSR-3接口复用了<a href="http://tools.ietf.org/html/rfc5424" target="_blank" rel="noopener">RFC-5424系统日志协议</a>，规定要实现9个方法。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Psr</span>\<span class="title">Log</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">LoggerInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">emergency</span><span class="params">($message, array $context = array<span class="params">()</span>)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">alert</span><span class="params">($message, array $context = array<span class="params">()</span>)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">critical</span><span class="params">($message, array $context = array<span class="params">()</span>)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">error</span><span class="params">($message, array $context = array<span class="params">()</span>)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">warning</span><span class="params">($message, array $context = array<span class="params">()</span>)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">notice</span><span class="params">($message, array $context = array<span class="params">()</span>)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">info</span><span class="params">($message, array $context = array<span class="params">()</span>)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">debug</span><span class="params">($message, array $context = array<span class="params">()</span>)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">log</span><span class="params">($level, $message, array $context = array<span class="params">()</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个方法对应RFC 5424协议的一个日志级别，而且都接受两个参数。第一个参数<code>$message</code>必须是一个字符串，或者是一个有<code>__toString()</code>方法的对象。第二个参数<code>$context</code>是可选的，这是一个数组，提供用于替换第一个参数中占位符的值。</p><p><code>$context</code>参数用于构造复杂的日志消息。消息文本中可以使用占位符，例如<code>{placeholder_name}</code>。占位符由{，占位符名称和}组成，不能包含空格。<code>$context</code>参数的值是一个关联数组，键是占位符的名称，对应的值用于替换消息文本中的占位符。</p><h3 id="PSR-4"><a href="#PSR-4" class="headerlink" title="PSR-4"></a>PSR-4</h3><p>PSR-4的精髓是把命名空间的前缀和文件系统中的目录对应起来。下面是一个PSR-4规范的自动加载器的例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $class 完全限定的类名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">spl_autoload(<span class="function"><span class="keyword">function</span> <span class="params">($class)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 项目命名空间前缀</span></span><br><span class="line">$prefix = <span class="string">'Foo\\Bar\\'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名空间对应的基目录</span></span><br><span class="line">$base_dir = <span class="keyword">__DIR__</span> . <span class="string">'/src/'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较传入的类名是否使用命名空间的前缀</span></span><br><span class="line">$len = strlen($prefix);</span><br><span class="line"><span class="keyword">if</span>(strncmp($prefix, $class, $len) !== <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取去除前缀的类名</span></span><br><span class="line">$relative_class = substr($class, $len);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类的地址</span></span><br><span class="line">$file = $base_dir . str_replace(<span class="string">'\\'</span>, <span class="string">'/'</span>, $relative_class) . <span class="string">'.php'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入文件</span></span><br><span class="line"><span class="keyword">if</span>(file_exists($file) &#123;</span><br><span class="line"><span class="keyword">require</span> $file;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>ModernPHP 系列全集：<a href="/modernphp/">传送门</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PSR是PHP Standards Recommendation（PHP推荐标准），规定了一系列PHP程序的标准方案。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="php" scheme="https://sidfate.github.io/categories/tech/php/"/>
    
    
      <category term="php" scheme="https://sidfate.github.io/tags/php/"/>
    
      <category term="modernphp" scheme="https://sidfate.github.io/tags/modernphp/"/>
    
  </entry>
  
  <entry>
    <title>ModernPHP FIG</title>
    <link href="https://sidfate.github.io/2016/09/12/tech/php/modernphp-fig/"/>
    <id>https://sidfate.github.io/2016/09/12/tech/php/modernphp-fig/</id>
    <published>2016-09-12T08:36:00.000Z</published>
    <updated>2018-10-16T09:37:23.854Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>PHP Framework Interop Group（框架协同工作组，简称<a href="http://www.php-fig.org" target="_blank" rel="noopener">PHP-FIG</a>，）<br><a id="more"></a></p><p>对于PHP这门语言，众所周知的是其组件和框架的数量极其的多，毕竟<strong>世界上最好的语言</strong>。<br><img src="http://sidfate.oss-cn-hangzhou.aliyuncs.com/image/6/e7/afd0e453d16963e7b3517473a5914.png" alt=""></p><p>如果你正在为项目选择PHP框架，你一定会为其多种多样的框架而头疼，例如有小巧精致的CI（CodeIgniter），最近几年都很火很全面的Laravel，国产框架ThinkPHP，或者企业使用广泛的Yii等等。</p><p>然后你可能会试着了解下每个框架的特性来个选出你想要的，你发现Symfony的辅助库很棒，大大减少了自己去封装时间，然而你考虑到你的项目的大小由此选择了CI，这时你会想到将Symfony的辅助库搬到CI框架中话就好了，但是你只能专门为你的项目编写一个一次性的适配器。</p><p>所以，看出问题了吗，单独开发的框架没有考虑到和其他框架的通信，而一旦你选择了这样的框架，你只能束缚在它的生态系统中了。 为了解决这个问题，一些PHP框架的开发者在php|tek碰头并组建了PHP Framework Interop Group（框架协同工作组，简称<a href="http://www.php-fig.org" target="_blank" rel="noopener">PHP-FIG</a>，）。PHP-FIG制定了推荐规范，PHP框架可以自愿的遵守这些规范，改进与其他框架通信和共享的功能。PHP-FIG是框架代表自发组织的，它发布的推荐规范，不是强制规范，你也可以申请加入其中，共同推进PHP社区的发展。</p><p><img src="http://sidfate.oss-cn-hangzhou.aliyuncs.com/image/6/f6/03c4d3a79c490b0fb0339850b2dc8.png" alt=""></p><p>PHP-FIG的使命是实现框架的互操作性，指的是通过接口，自动加载机制和标准的风格，让框架相互合作。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>PHP框架之间通过共用的接口合作，框架只需要知道第三方依赖能提供什么方法，并不需要知道方法具体是如何实现的。PHP开发者使用接口可以开发、共享并使用专门的组件，而无需使用庞大的框架。</p><h3 id="自动加载"><a href="#自动加载" class="headerlink" title="自动加载"></a>自动加载</h3><p>PHP框架之间通过自动加载机制合作。自动加载即时PHP解释器在运行时按需自动找到并加载PHP类的过程，在PHP标准出现之前，PHP组件和框架会使用魔术方法<code>__autoload()</code>或<code>spl_autoload_register()</code>方法实现各自的自动加载器。因此，你要去学习每个框架各自的加载器，但是现在，很多框架都遵守一个自动加载器标准，我们可以只使用一个自动加载器就能混合搭配多个PHP组件。</p><h4 id="风格"><a href="#风格" class="headerlink" title="风格"></a>风格</h4><p>风格指的的是标准的代码风格，即如何使用空格、大小写、括号的位置等等。即使在一个团队合作的项目中，我们都知道共同使用一种代码风格的好处，从代码的可阅读性，可维护性上都有很大的帮助。将代码风格标准化还能降低项目新贡献者的门槛，让他们能花更多时间用在提升框架的价值上，而不是为不同的风格而头疼。</p><blockquote><p>php-fig中文github：<a href="https://github.com/hfcorriez/fig-standards" target="_blank" rel="noopener">传送门</a></p></blockquote><blockquote><p>ModernPHP 系列全集：<a href="/modernphp/">传送门</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PHP Framework Interop Group（框架协同工作组，简称&lt;a href=&quot;http://www.php-fig.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PHP-FIG&lt;/a&gt;，）&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="php" scheme="https://sidfate.github.io/categories/tech/php/"/>
    
    
      <category term="php" scheme="https://sidfate.github.io/tags/php/"/>
    
      <category term="modernphp" scheme="https://sidfate.github.io/tags/modernphp/"/>
    
  </entry>
  
  <entry>
    <title>ModernPHP 闭包</title>
    <link href="https://sidfate.github.io/2016/08/28/tech/php/modernphp-closure/"/>
    <id>https://sidfate.github.io/2016/08/28/tech/php/modernphp-closure/</id>
    <published>2016-08-28T08:51:00.000Z</published>
    <updated>2018-10-16T10:06:04.073Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍PHP中的闭包和匿名函数的概念，以及它们的具体使用。<br><a id="more"></a></p><h3 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h3><p>闭包和匿名函数是PHP5.3.0中引入的特性。下面介绍下这两个概念的定义，可能看上去会比较难理解，但是后面会给出实例可以更好的掌握。</p><p>闭包指的是在创建时封装周围状态的函数。即便闭包所在的环境不存在了，闭包中封装的状态依然存在。</p><p>匿名函数其实是没有名字的函数，匿名函数可以赋值给变量，也能像对象那样被传递，常常被用作函数或者方法的回调。</p><p>理论上讲，闭包和匿名函数是不同的概念，但是PHP将其是做相同的概念。PHP闭包的语法和普通函数相同，但是其实它是伪装成函数的对象，事实上是Closure类的实例。</p><h3 id="0x01-闭包的创建"><a href="#0x01-闭包的创建" class="headerlink" title="0x01 闭包的创建"></a>0x01 闭包的创建</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$closure = <span class="function"><span class="keyword">function</span><span class="params">($name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sprintf(<span class="string">'Hello %s'</span>, $name);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> $closure(<span class="string">"Josh"</span>);</span><br><span class="line"><span class="comment">// 输出 Hello Josh</span></span><br></pre></td></tr></table></figure><p>我们之所以能够调用$closure变量，是因为这个变量的值是一个闭包，而且闭包对象实现了__invoke()魔术方法。只要变量名后有()，PHP就会去查找并调用__invoke()方法。</p><p>很多的PHP函数会用到回调函数，比如array_map()和preg_replace_callback()函数。下面的例子给出了将闭包对象作为回调参数传给array_map()函数。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$numberPlusOne = array_map(<span class="function"><span class="keyword">function</span><span class="params">($nunmber)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $number + <span class="number">1</span>;</span><br><span class="line">&#125;, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"> </span><br><span class="line">print_r($numberPlusOne);</span><br><span class="line"><span class="comment">// 输出 [2, 3, 4]</span></span><br></pre></td></tr></table></figure></p><h3 id="0x01-附加状态"><a href="#0x01-附加状态" class="headerlink" title="0x01 附加状态"></a>0x01 附加状态</h3><p>如果你了解JavaScript的闭包，你应该知道JavaScript的闭包会自动封装引用的状态。但在PHP中并不会，你必须手动调用闭包对象的bindTo()方法或者使用use关键字，把状态附加到PHP闭包中。</p><p>使用use关键字附加状态常见得多，下面给出了例子，use关键字将变量附加到闭包时，附加的变量会记住附加时赋予它的值。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enclosePerson</span><span class="params">($name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">($doCommand)</span> <span class="title">use</span> <span class="params">($name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sprintf(<span class="string">'%s, %s'</span>, $name, $doCommand);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将字符串"Clay"封装在闭包中</span></span><br><span class="line">$clay = enclosePerson(<span class="string">"Clay"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 传入参数，调用闭包</span></span><br><span class="line"><span class="keyword">echo</span> $clay(<span class="string">'go away!'</span>);</span><br><span class="line"><span class="comment">// 输出 "Clay, go away!"</span></span><br></pre></td></tr></table></figure></p><p>上述例子中，enclosePerson函数有一个参数$name，这个函数返回一个闭包对象，并且在闭包对象中封装了$name参数。即便返回的闭包对象跳出了enclosePerson()函数的作用域，$name参数的值还是能获取到，因为$name变量仍在闭包中。</p><p>上面提到过，PHP闭包是对象，它有一个bindTo方法，这个方法可以把Closure对象的内部状态绑定到其他对象上。bindTo的第二个参数很重要，其作用是指定绑定闭包的那个对象所属的PHP类。因此闭包可以访问闭包对象中受保护和私有的成员变量。</p><p>PHP框架经常使用bindTo方法把路由URL映射到匿名函数上。框架会把匿名函数绑定到应用对象上，这么做可以在这个匿名函数中使用$this关键字引用重要的应用对象，下面给出例子。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $routes = [];</span><br><span class="line">    <span class="keyword">protected</span> $responseStatus = <span class="string">"200 OK"</span>;</span><br><span class="line">    <span class="keyword">protected</span> $responseContentType = <span class="string">"text/html"</span>;</span><br><span class="line">    <span class="keyword">protected</span> $responseBody = <span class="string">"Hello world"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addRoute</span><span class="params">($routePath, $routeCallback)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;routes[$routePath] = $routeCallback-&gt;bindTo(<span class="keyword">$this</span>, <span class="keyword">__CLASS__</span>);</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span><span class="params">($currentPath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;routes <span class="keyword">as</span> $routePath =&gt; $callback) &#123;</span><br><span class="line">            <span class="keyword">if</span>($routePath === $currentPath) &#123;</span><br><span class="line">                $callback();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        header(<span class="string">'HTTP/1.1 '</span> . <span class="keyword">$this</span>-&gt;responseStatus);</span><br><span class="line">        header(<span class="string">'Content-type: '</span> . <span class="keyword">$this</span>-&gt;responseContentType);</span><br><span class="line">        header(<span class="string">'Content-length: '</span> . mb_strlen(<span class="keyword">$this</span>-&gt;responseBody));</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;responseBody;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>App类中的addRoute()方法，它有2个参数，分别是路由路径（例如/users/josh）字符串和一个路由回调。dispatch()方法的参数是当前HTTP请求的路径，它会调用匹配的路由回调。第10行是重点，我们把回调函数绑定在了当前的App实例中，这么做就能在回调函数中处理App实例的状态。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$app = <span class="keyword">new</span> App();</span><br><span class="line">$app-&gt;addRoute(<span class="string">'/users/josh'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;responseContentType = <span class="string">'application/json;charset=utf8'</span>;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;responseBody = json_encode([<span class="string">'name'</span>=&gt; <span class="string">'josh'</span>]);</span><br><span class="line">&#125;);</span><br><span class="line">$app-&gt;dispatch(<span class="string">'/users/josh'</span>);</span><br></pre></td></tr></table></figure></p><blockquote><p>ModernPHP 系列全集：<a href="/modernphp/">传送门</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍PHP中的闭包和匿名函数的概念，以及它们的具体使用。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="php" scheme="https://sidfate.github.io/categories/tech/php/"/>
    
    
      <category term="php" scheme="https://sidfate.github.io/tags/php/"/>
    
      <category term="modernphp" scheme="https://sidfate.github.io/tags/modernphp/"/>
    
  </entry>
  
  <entry>
    <title>ModernPHP 生成器</title>
    <link href="https://sidfate.github.io/2016/08/28/tech/php/modernphp-generator/"/>
    <id>https://sidfate.github.io/2016/08/28/tech/php/modernphp-generator/</id>
    <published>2016-08-28T08:39:00.000Z</published>
    <updated>2018-10-16T10:06:22.116Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍PHP中生成器的概念，以及它的应用。<br><a id="more"></a></p><h3 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h3><p>PHP生成器是PHP5.5.0引入的功能，生成器就是简单的迭代器，但与标准的PHP迭代器不同，PHP生成器不要求实现Iterator接口，从而减轻了类的负担。生成器会根据需求计算并产出要迭代的值，这对应用性能的影响重大。假如标准的PHP迭代器经常在内存中执行迭代操作，这要预先计算出数据集，性能低下；如果要使用特定的方式计算大量数据，对性能的影响更甚。此时我们使用生成器，即时计算出产出后续值，不占用宝贵的内存资源。</p><p>PHP生成器不能满足所有迭代操作的需求，因为如果不查询，生成器永远不知道下一个要迭代的值是什么，在生成器中无法快进或后退。生成器还是一次性的，无法多次迭代同一个生成器。不过，如果需要，可以重建或克隆生成器。</p><h3 id="0x01-生成器的创建"><a href="#0x01-生成器的创建" class="headerlink" title="0x01 生成器的创建"></a>0x01 生成器的创建</h3><p>生成器的创建很简单，因为生成器就是PHP函数，只不过要在函数中一次或多次使用yield关键字。与普通的PHP函数不同的是，生成器从不返回值，只产出值。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'value1'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'value2'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'value3'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用生成器函数时，PHP会返回一个属于Generator类的对象。这个对象可以使用foreach()函数迭代。每次迭代，PHP会要求Generator实例计算并提供下一个要迭代的值。生成器的优雅体现在，每次产出一个值后，生成器的内部状态会停顿；向生成器请求下一个值时，内部状态又会恢复。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> ($myGenerator <span class="keyword">as</span> $yieldedValue) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $yieldedValue, PHP_EOL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// value1</span></span><br><span class="line"><span class="comment">// value2</span></span><br><span class="line"><span class="comment">// value3</span></span><br></pre></td></tr></table></figure></p><h3 id="0x02-生成器的使用"><a href="#0x02-生成器的使用" class="headerlink" title="0x02 生成器的使用"></a>0x02 生成器的使用</h3><p>下面我们来实现一个简单的函数，用于生成一个大范围内数值集合。</p><p>一个普通的栗子：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRange</span><span class="params">($length)</span> </span>&#123;</span><br><span class="line">    $dataset = [];</span><br><span class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>; $i&lt;$length; $i++) &#123;</span><br><span class="line">        $dataset[] = $i;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> $dataset;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$customRange = makeRange(<span class="number">1000000</span>);</span><br><span class="line"><span class="keyword">foreach</span> ($customRange <span class="keyword">as</span> $i) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $i, PHP_EOL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述的代码没有善用内存，因为makeRange()函数要为预先创建的一个有一百万个整数组成的数组分配内存。PHP生成器实现相同的操作。不过一个只会为一个整数分配内存。</p><p>使用生成器的栗子：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRange</span><span class="params">($length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>; $i&lt;$length; $i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> $i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">foreach</span> (makeRange(<span class="number">1000000</span>) <span class="keyword">as</span> $i) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $i, PHP_EOL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这只是一个虚构的例子，在现实中，你可以想象一下使用生成器可以计算什么样的数据集。假设我们现在想迭代一个4GB的文本文件（例如黑客字典），而你的内存可能比4GB还小，这时候就不能把整个文件加载到内存中，下面使用生成器来实现读取一个cvs文件。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRows</span><span class="params">($file)</span> </span>&#123;</span><br><span class="line">    $handle = fopen($file, <span class="string">'rb'</span>);</span><br><span class="line">    <span class="keyword">if</span>($handle === <span class="keyword">false</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(feof($handle) === <span class="keyword">false</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> fgetcsv($handle);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose($handle);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">foreach</span> (getRows(<span class="string">'data.csv'</span>) <span class="keyword">as</span> $row) &#123;</span><br><span class="line">    print_r($row);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子一次只会为csv文件的一行分配内存。迭代大型数据集或者数列时最适合使用生成器，因为这样占用的系统内存量极少。</p><blockquote><p>ModernPHP 系列全集：<a href="/modernphp/">传送门</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍PHP中生成器的概念，以及它的应用。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="php" scheme="https://sidfate.github.io/categories/tech/php/"/>
    
    
      <category term="php" scheme="https://sidfate.github.io/tags/php/"/>
    
      <category term="modernphp" scheme="https://sidfate.github.io/tags/modernphp/"/>
    
  </entry>
  
  <entry>
    <title>ModernPHP 性状</title>
    <link href="https://sidfate.github.io/2016/08/28/tech/php/modernphp-trait/"/>
    <id>https://sidfate.github.io/2016/08/28/tech/php/modernphp-trait/</id>
    <published>2016-08-28T06:30:00.000Z</published>
    <updated>2018-10-16T10:06:43.891Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文讲述了何谓性状，以及PHP中性状出现的意义，怎么去使用。<br><a id="more"></a></p><h3 id="0x00-性状是什么"><a href="#0x00-性状是什么" class="headerlink" title="0x00 性状是什么"></a>0x00 性状是什么</h3><p>这是PHP5.4.0引入的概念，既像类又像接口。性状是类的部分实现（即常量，属性和方法），可以混入一个或多个类中。性状有两个作用：表名类可以做什么（像是接口），提供模块化的实现（像是类）。</p><h3 id="0x01-性状的作用"><a href="#0x01-性状的作用" class="headerlink" title="0x01 性状的作用"></a>0x01 性状的作用</h3><p>PHP语言使用的是典型的继承模型。在这个模型中，我们先创建基类，实现基本的功能，然后扩展这个基类，通过继承基类创建更多具体的类。这叫做继承层次结构，很多编程语言都是用这个模式。</p><p>但是，如果想让两个无关的PHP类具有类型的行为，应该如何去做？例如，Satellite（卫星类）和Car（汽车类）两个类的作用十分不同，在继承层次结构上没有共同的父类，但是这两个类应该都能使用地理编码技术转换成经纬度，然后在地图上显示。</p><p>这时候就可以使用性状来解决。性状可以把模块化的实现方式注入到多个无关的类中，还能促进代码的重用。</p><h3 id="0x02-性状的创建"><a href="#0x02-性状的创建" class="headerlink" title="0x02 性状的创建"></a>0x02 性状的创建</h3><p>定义一个性状：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">trait</span> MyTrait &#123;</span><br><span class="line">    <span class="comment">// 实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们接着使用上面提到的例子来演示如何使用性状。我们希望Satellite和Car类都能提供地理编码功能，而且意识到继承和接口都不是最佳方案。我们选择创建Geocodable（地理编码）性状，返回经纬度，然后在地图中绘制。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">trait</span> Geocodable &#123;</span><br><span class="line">    <span class="comment">/* <span class="doctag">@var</span> string */</span></span><br><span class="line">    <span class="keyword">protected</span> $address;</span><br><span class="line">    <span class="comment">/* <span class="doctag">@var</span> \Geocoder\Geocoder */</span></span><br><span class="line">    <span class="keyword">protected</span> $geocoder;</span><br><span class="line">    <span class="comment">/* <span class="doctag">@var</span> \Geocoder\Result\Geocoded */</span></span><br><span class="line">    <span class="keyword">protected</span> $geocoderResult;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setGeocoder</span><span class="params">(\Geocoder\GeocoderInterface $geocoder)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;geocoder = $geocoder;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setAddress</span><span class="params">($address)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;address = $address;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getLatitude</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;geocoderResult)) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;geocodeAddress();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;geocoderResult-&gt;getLatitude();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getLongitude</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;geocoderResult)) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;geocodeAddress();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;geocoderResult-&gt;getLongitude();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">geocodeAddress</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;geocoderResult = <span class="keyword">$this</span>-&gt;geocoder-&gt;geocode(<span class="keyword">$this</span>-&gt;address);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个Geocodable性状定义了三个类属性：一个表示地址；一个是地理编码器对象（\Geocoder\Geocoder类的实例，这个类是来自第三方的组件）；一个是地理编码器处理后的结果对象（\Geocoder\Result\Geocoded类的实例）。我们还定义了4个公有方法和一个受保护的方法。setGeocoder()方法用于注入Geocoder对象；setAddress()方法用于设定地址；getLatitude()和getLongitude()用于返回经纬度；geocodeAddress()方法把地址字符串传给Geocoder实例，获取地理编码器处理的结果。</p><h3 id="0x03-性状的使用"><a href="#0x03-性状的使用" class="headerlink" title="0x03 性状的使用"></a>0x03 性状的使用</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">MyTrait</span>;</span><br><span class="line">    <span class="comment">// 类的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意，PHP解释器在编译的时候会把性状复制黏贴到类的定义体中，但是不会处理这个操作引入的不兼容问题。如果性状假定类中有特定的方法或属性（在性状中没有定义），要确保相应的类中有对应的属性和方法。</p><blockquote><p>ModernPHP 系列全集：<a href="/modernphp/">传送门</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文讲述了何谓性状，以及PHP中性状出现的意义，怎么去使用。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="php" scheme="https://sidfate.github.io/categories/tech/php/"/>
    
    
      <category term="php" scheme="https://sidfate.github.io/tags/php/"/>
    
      <category term="modernphp" scheme="https://sidfate.github.io/tags/modernphp/"/>
    
  </entry>
  
</feed>
