<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sidfate</title>
  
  <subtitle>sidfate&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sidfate.github.io/"/>
  <updated>2018-10-06T14:30:33.686Z</updated>
  <id>https://sidfate.github.io/</id>
  
  <author>
    <name>Sidfate</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>test_car</title>
    <link href="https://sidfate.github.io/2018/10/06/car/test-car/"/>
    <id>https://sidfate.github.io/2018/10/06/car/test-car/</id>
    <published>2018-10-06T14:29:40.000Z</published>
    <updated>2018-10-06T14:30:33.686Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="car" scheme="https://sidfate.github.io/categories/car/"/>
    
    
  </entry>
  
  <entry>
    <title>扫盲篇 - cookie&amp;session</title>
    <link href="https://sidfate.github.io/2018/10/02/tech/literacy/cookie-session/"/>
    <id>https://sidfate.github.io/2018/10/02/tech/literacy/cookie-session/</id>
    <published>2018-10-02T03:33:42.000Z</published>
    <updated>2018-10-12T09:20:11.581Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-开始"><a href="#0x00-开始" class="headerlink" title="0x00 开始"></a>0x00 开始</h3><p>试想一下，如果现在突然有一个面试官问你：什么是Cookie？什么是Session？你会怎么回答。</p><p>我想了下，首先大脑中的经验告诉我cookie是客户端缓存信息的一种方式，session则是放在服务端。但是这种说法总觉得有些牵强，于是下面我们从一个具体的请求出发，来看看它们在实际中是怎么应用的。</p><a id="more"></a><h3 id="0x01-从一个登录的http请求出发"><a href="#0x01-从一个登录的http请求出发" class="headerlink" title="0x01 从一个登录的http请求出发"></a>0x01 从一个登录的http请求出发</h3><!-- 在具体分析请求之前，我们先思考一个问题，在浏览器中，加入我们登录github后，在一定时间段内，我们是不需要重新登录的，也就是说即使关闭了网页或者浏览器，下次进入github还是登录的状态。那么浏览器和github的服务端是怎么实现这种的呢。 --><p>请注意一个前提，http是无状态的协议，无状态导致了服务器不知道客户端处理请求的结果。也就是说我们一个登录流程，用户在网页上输入账号密码并点击登录，浏览器发送登录请求，服务器收到请求并验证用户，记录用户登录状态，然后返回成功登录的信息，最后浏览器收到成功的消息，但是在下次浏览器发送请求时，如果这时候请求没有做特殊的处理，我是无法知道这个用户是否登录的状态。</p><p>在登录请求中，浏览器发送请求后，我们看下服务端做了什么处理：</p><ol><li>设置了session记录当前登录的用户的账号。</li><li>在返回的头信息中有一个特殊头，Set-Cookie，其中包含了sessionId的信息</li></ol><p>sessionId也是服务端自动生成。</p><h3 id="0x02-在app中登录"><a href="#0x02-在app中登录" class="headerlink" title="0x02 在app中登录"></a>0x02 在app中登录</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00-开始&quot;&gt;&lt;a href=&quot;#0x00-开始&quot; class=&quot;headerlink&quot; title=&quot;0x00 开始&quot;&gt;&lt;/a&gt;0x00 开始&lt;/h3&gt;&lt;p&gt;试想一下，如果现在突然有一个面试官问你：什么是Cookie？什么是Session？你会怎么回答。&lt;/p&gt;
&lt;p&gt;我想了下，首先大脑中的经验告诉我cookie是客户端缓存信息的一种方式，session则是放在服务端。但是这种说法总觉得有些牵强，于是下面我们从一个具体的请求出发，来看看它们在实际中是怎么应用的。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://sidfate.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="扫盲" scheme="https://sidfate.github.io/categories/%E6%8A%80%E6%9C%AF/%E6%89%AB%E7%9B%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>分享篇 - 走进XSS</title>
    <link href="https://sidfate.github.io/2018/09/30/tech/share/front-xss/"/>
    <id>https://sidfate.github.io/2018/09/30/tech/share/front-xss/</id>
    <published>2018-09-30T01:31:28.000Z</published>
    <updated>2018-10-05T10:05:39.401Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>关键词：<code>XSS</code>，<code>html渲染</code>，<code>前端安全</code></p><a id="more"></a><p><a href="https://xss-game.appspot.com" target="_blank" rel="noopener">一个小游戏</a></p><h3 id="0x01-概念"><a href="#0x01-概念" class="headerlink" title="0x01 概念"></a>0x01 概念</h3><p>“跨站脚本攻击”（Cross Site Scripting)</p><p>第一种分类方式：</p><ol><li>非持久型攻击<br> 顾名思义，非持久型xss攻击是一次性的，仅对当次的页面访问产生影响。非持久型xss攻击要求用户访问一个被攻击者篡改后的链接，用户访问该链接时，被植入的攻击脚本被用户游览器执行，从而达到攻击目的。</li><li>持久型攻击<br> 持久型xss，会把攻击者的数据存储在服务器端，攻击行为将伴随着攻击数据一直存在。</li></ol><p>第二种分类方式：</p><ol><li><p>反射型：经过后端，不经过数据库</p></li><li><p>存储型：经过后端，经过数据库</p></li><li><p>DOM：不经过后端,DOM—based XSS漏洞是基于文档对象模型Document Objeet Model,DOM)的一种漏洞,dom - xss是通过url传入参数去控制触发的</p></li></ol><h3 id="0x02-总结"><a href="#0x02-总结" class="headerlink" title="0x02 总结"></a>0x02 总结</h3><blockquote><p>“大多数职业（从医生到电工），多年的经验等同于多年的专业知识。但是在软件开发中，技术变化如此之快，你花费了大量时间学习技术和工具，一旦这些技术被取代，你的知识将变得毫无价值，因为它们大部分都是实施的细节。最终，所有这些年，你确实积累了一些一般性的经验，但与具体实施相关的知识，你都不再掌握了。<br>唯一留下的是那些基本的东西，你应该专注于软件开发的核心知识和数学知识，您的这些技能会不断增长，而不是随着技术潮流的变化而消失。”</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;关键词：&lt;code&gt;XSS&lt;/code&gt;，&lt;code&gt;html渲染&lt;/code&gt;，&lt;code&gt;前端安全&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="分享" scheme="https://sidfate.github.io/categories/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="xss" scheme="https://sidfate.github.io/tags/xss/"/>
    
  </entry>
  
  <entry>
    <title>Linux Python安装</title>
    <link href="https://sidfate.github.io/2017/02/21/tech/devops/linux-python-install/"/>
    <id>https://sidfate.github.io/2017/02/21/tech/devops/linux-python-install/</id>
    <published>2017-02-21T01:23:00.000Z</published>
    <updated>2018-10-12T10:16:05.636Z</updated>
    
    <content type="html"><![CDATA[<p>文本介绍如何在linux中将python更新到最新版本。<br><a id="more"></a></p><h3 id="0x00-前提"><a href="#0x00-前提" class="headerlink" title="0x00 前提"></a>0x00 前提</h3><p>一般来说，linux系统都会自带python，但是python的版本不会是最新的，例如centos6.5的是2.6.6的，接下来我们就将系统的python更新到2.7的最新版本。</p><h3 id="0x00-开始"><a href="#0x00-开始" class="headerlink" title="0x00 开始"></a>0x00 开始</h3><p>首先从官网下载最新版的python</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> wget https://www.python.org/ftp/python/2.7.13/Python-2.7.13.tar.xz</span><br></pre></td></tr></table></figure><p>这个过程可能比较慢，官网下就是很慢orz。下完后解压然后开始安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> tar -xvf Python-2.7.13.tar.xz</span><br><span class="line"><span class="meta">$</span> cd Python-2.7.13/</span><br><span class="line"><span class="meta">$</span> ./configure</span><br><span class="line"><span class="meta">$</span> make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>这个过程也会需要一段时间，如果中途报错，基本就是gcc的原因，先更新gcc(<code>yum -y install gcc</code>)再重新安装。默认会将python安装<code>/usr/local/bin/python2.7</code></p><h3 id="0x01-配置"><a href="#0x01-配置" class="headerlink" title="0x01 配置"></a>0x01 配置</h3><p>上述步骤完成后我们来看现在系统中python的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> /usr/local/bin/python2.7 -V</span><br><span class="line">Python 2.7.13</span><br><span class="line"><span class="meta">$</span> python -V</span><br><span class="line">Python 2.6.6</span><br></pre></td></tr></table></figure><p>可以看到我们系统默认的python还是老版本的，说明我们<code>/usr/bin/python</code>仍然指向2.6的python，所以接下来首先给旧版换个名称，然后将<code>/usr/bin/python</code>指向我们新版python的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> mv /usr/bin/python /usr/bin/python26</span><br><span class="line"><span class="meta">$</span> ln -s /usr/local/bin/python2.7 /usr/bin/python </span><br><span class="line"><span class="meta">$</span> python -V</span><br><span class="line">Python 2.7.13</span><br></pre></td></tr></table></figure><p>ok，还剩最后一步，修改yum的配置，因为yum用的是老版本的python，我们更新系统的python后导致yum所使用的python版本不符</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> vi /usr/bin/yum</span><br><span class="line"><span class="meta">#</span>!/usr/bin/python</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>看到没，yum使用的是系统的python，我们将其第一行改成<code>#!/usr/bin/python26</code>就ok了。</p><h3 id="PIP安装"><a href="#PIP安装" class="headerlink" title="PIP安装"></a>PIP安装</h3><p>至此我们python的更新已经完成了，接下来再来安装个pip，pip是python的包管理器，可以说pip之于python类似于npm之于node，可想而知其重要性。关于pip的安装，以下给出一个最实用的安装方式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> wget https://bootstrap.pypa.io/get-pip.py</span><br><span class="line"><span class="meta">$</span> python get-pip.py</span><br></pre></td></tr></table></figure><p>get-pip.py 会根据你的python版本自动安装pip及其依赖包（setuptools）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文本介绍如何在linux中将python更新到最新版本。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="devops" scheme="https://sidfate.github.io/categories/tech/devops/"/>
    
    
      <category term="linux" scheme="https://sidfate.github.io/tags/linux/"/>
    
      <category term="python" scheme="https://sidfate.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python urllib2多线程</title>
    <link href="https://sidfate.github.io/2017/01/21/tech/python/python-urllib2-threads/"/>
    <id>https://sidfate.github.io/2017/01/21/tech/python/python-urllib2-threads/</id>
    <published>2017-01-21T03:26:23.000Z</published>
    <updated>2018-10-12T10:57:31.525Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍怎么使用urllib2和thread让你的爬虫多线程运行。<br><a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock</span><br><span class="line"><span class="keyword">from</span> Queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fetcher</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, threads)</span>:</span></span><br><span class="line">        self.opener = urllib2.build_opener(urllib2.HTTPHandler)</span><br><span class="line">        self.lock = Lock()</span><br><span class="line">        self.q_req = Queue()</span><br><span class="line">        self.q_ans = Queue()</span><br><span class="line">        self.threads = threads</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(threads):</span><br><span class="line">            t = Thread(target=self.get_thread)</span><br><span class="line">            t.setDaemon(<span class="keyword">True</span>)</span><br><span class="line">            t.start()</span><br><span class="line">        self.running = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        self.q_req.join()</span><br><span class="line">        self.q_ans.join()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_task</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.q_req.qsize()+self.q_ans.qsize()+self.running</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, req)</span>:</span></span><br><span class="line">        self.q_req.put(req)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.q_ans.get()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_thread</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            req = self.q_req.get()</span><br><span class="line">            <span class="keyword">with</span> self.lock:</span><br><span class="line">                self.running += <span class="number">1</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                ans = self.opener.open(req).read()</span><br><span class="line">            <span class="keyword">except</span> Exception, what:</span><br><span class="line">                ans = <span class="string">''</span></span><br><span class="line">                <span class="keyword">print</span> what</span><br><span class="line">            self.q_ans.put((req, ans))</span><br><span class="line">            <span class="keyword">with</span> self.lock:</span><br><span class="line">                self.running -= <span class="number">1</span></span><br><span class="line">            self.q_req.task_done()</span><br><span class="line">            time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    links = [<span class="string">'http://www.verycd.com/topics/%d/'</span> % i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5420</span>, <span class="number">5430</span>)]</span><br><span class="line">    f = Fetcher(threads=<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> links:</span><br><span class="line">        f.push(url)</span><br><span class="line">    <span class="keyword">while</span> f.get_task():</span><br><span class="line">        url, content = f.pop()</span><br><span class="line">        <span class="keyword">print</span> url, len(content)</span><br></pre></td></tr></table></figure><blockquote><p>更多爬虫技巧请戳<a href="/spider">传送门</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍怎么使用urllib2和thread让你的爬虫多线程运行。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="python" scheme="https://sidfate.github.io/categories/tech/python/"/>
    
    
      <category term="python" scheme="https://sidfate.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Linux 搭建svn服务器</title>
    <link href="https://sidfate.github.io/2017/01/21/tech/devops/linux-svn-install/"/>
    <id>https://sidfate.github.io/2017/01/21/tech/devops/linux-svn-install/</id>
    <published>2017-01-21T01:40:23.000Z</published>
    <updated>2018-10-12T10:47:05.562Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍在linux搭建自己的svn服务器。<br><a id="more"></a></p><h3 id="0x00-开始"><a href="#0x00-开始" class="headerlink" title="0x00 开始"></a>0x00 开始</h3><ol><li><p>通过yum直接安装subversion</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> yum install subversion</span><br></pre></td></tr></table></figure></li><li><p>创建版本库。版本库是一个svn用来进行版本管理的控制中心，我们将/home/svn作为我们管理所有版本库的目录，然后在其中创建一个project的版本库。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> mkdir /home/svn</span><br><span class="line"><span class="meta">$</span> svnadmin create /home/svn/project</span><br></pre></td></tr></table></figure></li><li><p>修改版本库配置。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd /home/svn/project &amp;&amp; ls</span><br><span class="line">conf  db  format  hooks  locks  README.txt</span><br></pre></td></tr></table></figure><p> 创建完毕的版本库中存在conf，hooks，locks等目录和文件。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd conf/ &amp;&amp; ls</span><br><span class="line">authz  passwd  svnserve.conf</span><br></pre></td></tr></table></figure><p> 进入conf目录我们能看到3个配置文件：authz，passwd，svnserve.conf。authz是svn用户的权限配置文件，passwd是svn用户密码的配置文件，svnserve.conf是版本库的主配置文件。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> vi passwd</span><br></pre></td></tr></table></figure><p> 我们先修改passwd，在文件末尾添加一行表示添加一个用户。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[users]</span><br><span class="line">sidfate = sidfate</span><br></pre></td></tr></table></figure><p> 然后修改authz，在文件末尾添加我们刚刚创建的svn用户对根目录的权限设置，这里我们设置为rw（读写），这里的根目录指的是版本库的根目录。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[/]</span><br><span class="line">sidfate = rw</span><br></pre></td></tr></table></figure><p> 最后修改svnserve.conf，去除下面配置前的注释。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">anon-access = read</span><br><span class="line">auth-access = write</span><br><span class="line">password-db = passwd</span><br><span class="line">authz-db = authz</span><br></pre></td></tr></table></figure><p> 这里说明一下，网上的资料有的说讲<code>realm = My First Repository</code>这一行也去注释，实际测试没有必要，还有如果你在客户端尝试checkout时出现权限验证的错误可以将<code>authz-db = authz</code>这一行注释回去就可以了。</p></li><li><p>启动和关闭svn服务。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> svnserve –d –r /home/svn/project/</span><br></pre></td></tr></table></figure><p>-d指明以守护模式运行，-r指定根目录，还可以使用–listen-port=切换监听端口，默认端口为3690。关闭svn服务可以使用以下命令。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ps -ef | grep svnserve</span><br><span class="line">root      1452   871  0 15:44 pts/0    00:00:00 grep svnserve</span><br><span class="line">root     29508     1  0 Jan20 ?        00:00:00 svnserve -d -r /home/svn/project/</span><br><span class="line"><span class="meta">$</span> kill 29508</span><br></pre></td></tr></table></figure></li><li><p>本地与服务器数据同步。我们现在可以在客户端环境checkout到本地，windows环境下可以使用第三方工具TortoiseSVN，操作很方便，如果是linux客户端，我们可以使用checkout命令。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ svn checkout svn://myurl/project</span><br></pre></td></tr></table></figure><p> 这里有一个误区，没有接触过版本控制的人可能尝试了在本地添加一个文件并上传，然后发现在服务器上找不到上传的文件。实际上版本控制记录了你的提交，你可以在本地的另一处checkout该项目发现你上传的文件已经存在了。在服务器上其实也是同一个道理，你在服务器上同样需要checkout一份代码，我们之前所作的其实就是创建了一个文件控制的中枢，你提交文件到svn服务器，然后在你的服务器上更新代码。也许你会觉得这个步骤繁琐了，别担心，我们可以使用svn的post-commit来自动同步代码的更新，来达到你本地的代码提交后服务器上的代码同步更新的功能。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd /home/svn/project/hooks </span><br><span class="line"><span class="meta">$</span> cp post-commit.tmpl post-commit</span><br><span class="line"><span class="meta">$</span> vi post-commit</span><br></pre></td></tr></table></figure><p> 找到你版本库的hooks目录，拷贝post-commit.tmpl为post-commit，然后编辑该文件，添加以下内容。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REPOS="$1"</span><br><span class="line">REV="$2"</span><br><span class="line">cd /home/wwwroot/project/ &amp;&amp; /usr/bin/svn update --username sidfate --password sidfate</span><br></pre></td></tr></table></figure><p> 注意第三条语句，/home/wwwroot/project/就是我放在服务器上的代码目录，这里的操作就是每次有svn提交后进入该目录然后更新代码。还要注意的是，请给予post-commit足够的权限，不然提交的时候会提示该文件出错。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> chmod 770 post-commit</span><br></pre></td></tr></table></figure><p> 仍然需要注意的一个问题是如果你的svn目录中存在中文命名的文件，那么可能会出现以下类似的错误:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn: Error converting entry in directory &apos;.&apos; to UTF-8</span><br></pre></td></tr></table></figure><p> 这个时候你需要在之前编写的post-commit文件里的命令前加上一段设置编码。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LANG=en_US.UTF-8 &amp;&amp; cd /home/wwwroot/project/ &amp;&amp; /usr/bin/svn update --username sidfate --password sidfate</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍在linux搭建自己的svn服务器。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="devops" scheme="https://sidfate.github.io/categories/tech/devops/"/>
    
    
      <category term="linux" scheme="https://sidfate.github.io/tags/linux/"/>
    
      <category term="svn" scheme="https://sidfate.github.io/tags/svn/"/>
    
  </entry>
  
  <entry>
    <title>ModernPHP 闭包</title>
    <link href="https://sidfate.github.io/2016/08/28/tech/php/modernphp-closure/"/>
    <id>https://sidfate.github.io/2016/08/28/tech/php/modernphp-closure/</id>
    <published>2016-08-28T08:51:00.000Z</published>
    <updated>2018-10-12T10:55:49.545Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍PHP中的闭包和匿名函数的概念，以及它们的具体使用。<br><a id="more"></a></p><h3 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h3><p>闭包和匿名函数是PHP5.3.0中引入的特性。下面介绍下这两个概念的定义，可能看上去会比较难理解，但是后面会给出实例可以更好的掌握。</p><p>闭包指的是在创建时封装周围状态的函数。即便闭包所在的环境不存在了，闭包中封装的状态依然存在。</p><p>匿名函数其实是没有名字的函数，匿名函数可以赋值给变量，也能像对象那样被传递，常常被用作函数或者方法的回调。</p><p>理论上讲，闭包和匿名函数是不同的概念，但是PHP将其是做相同的概念。PHP闭包的语法和普通函数相同，但是其实它是伪装成函数的对象，事实上是Closure类的实例。</p><h3 id="0x01-闭包的创建"><a href="#0x01-闭包的创建" class="headerlink" title="0x01 闭包的创建"></a>0x01 闭包的创建</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$closure = <span class="function"><span class="keyword">function</span><span class="params">($name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sprintf(<span class="string">'Hello %s'</span>, $name);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> $closure(<span class="string">"Josh"</span>);</span><br><span class="line"><span class="comment">// 输出 Hello Josh</span></span><br></pre></td></tr></table></figure><p>我们之所以能够调用$closure变量，是因为这个变量的值是一个闭包，而且闭包对象实现了__invoke()魔术方法。只要变量名后有()，PHP就会去查找并调用__invoke()方法。</p><p>很多的PHP函数会用到回调函数，比如array_map()和preg_replace_callback()函数。下面的例子给出了将闭包对象作为回调参数传给array_map()函数。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$numberPlusOne = array_map(<span class="function"><span class="keyword">function</span><span class="params">($nunmber)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $number + <span class="number">1</span>;</span><br><span class="line">&#125;, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"> </span><br><span class="line">print_r($numberPlusOne);</span><br><span class="line"><span class="comment">// 输出 [2, 3, 4]</span></span><br></pre></td></tr></table></figure></p><h3 id="0x01-附加状态"><a href="#0x01-附加状态" class="headerlink" title="0x01 附加状态"></a>0x01 附加状态</h3><p>如果你了解JavaScript的闭包，你应该知道JavaScript的闭包会自动封装引用的状态。但在PHP中并不会，你必须手动调用闭包对象的bindTo()方法或者使用use关键字，把状态附加到PHP闭包中。</p><p>使用use关键字附加状态常见得多，下面给出了例子，use关键字将变量附加到闭包时，附加的变量会记住附加时赋予它的值。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enclosePerson</span><span class="params">($name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">($doCommand)</span> <span class="title">use</span> <span class="params">($name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sprintf(<span class="string">'%s, %s'</span>, $name, $doCommand);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将字符串"Clay"封装在闭包中</span></span><br><span class="line">$clay = enclosePerson(<span class="string">"Clay"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 传入参数，调用闭包</span></span><br><span class="line"><span class="keyword">echo</span> $clay(<span class="string">'go away!'</span>);</span><br><span class="line"><span class="comment">// 输出 "Clay, go away!"</span></span><br></pre></td></tr></table></figure></p><p>上述例子中，enclosePerson函数有一个参数$name，这个函数返回一个闭包对象，并且在闭包对象中封装了$name参数。即便返回的闭包对象跳出了enclosePerson()函数的作用域，$name参数的值还是能获取到，因为$name变量仍在闭包中。</p><p>上面提到过，PHP闭包是对象，它有一个bindTo方法，这个方法可以把Closure对象的内部状态绑定到其他对象上。bindTo的第二个参数很重要，其作用是指定绑定闭包的那个对象所属的PHP类。因此闭包可以访问闭包对象中受保护和私有的成员变量。</p><p>PHP框架经常使用bindTo方法把路由URL映射到匿名函数上。框架会把匿名函数绑定到应用对象上，这么做可以在这个匿名函数中使用$this关键字引用重要的应用对象，下面给出例子。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $routes = [];</span><br><span class="line">    <span class="keyword">protected</span> $responseStatus = <span class="string">"200 OK"</span>;</span><br><span class="line">    <span class="keyword">protected</span> $responseContentType = <span class="string">"text/html"</span>;</span><br><span class="line">    <span class="keyword">protected</span> $responseBody = <span class="string">"Hello world"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addRoute</span><span class="params">($routePath, $routeCallback)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;routes[$routePath] = $routeCallback-&gt;bindTo(<span class="keyword">$this</span>, <span class="keyword">__CLASS__</span>);</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span><span class="params">($currentPath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;routes <span class="keyword">as</span> $routePath =&gt; $callback) &#123;</span><br><span class="line">            <span class="keyword">if</span>($routePath === $currentPath) &#123;</span><br><span class="line">                $callback();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        header(<span class="string">'HTTP/1.1 '</span> . <span class="keyword">$this</span>-&gt;responseStatus);</span><br><span class="line">        header(<span class="string">'Content-type: '</span> . <span class="keyword">$this</span>-&gt;responseContentType);</span><br><span class="line">        header(<span class="string">'Content-length: '</span> . mb_strlen(<span class="keyword">$this</span>-&gt;responseBody));</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;responseBody;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>App类中的addRoute()方法，它有2个参数，分别是路由路径（例如/users/josh）字符串和一个路由回调。dispatch()方法的参数是当前HTTP请求的路径，它会调用匹配的路由回调。第10行是重点，我们把回调函数绑定在了当前的App实例中，这么做就能在回调函数中处理App实例的状态。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$app = <span class="keyword">new</span> App();</span><br><span class="line">$app-&gt;addRoute(<span class="string">'/users/josh'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;responseContentType = <span class="string">'application/json;charset=utf8'</span>;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;responseBody = json_encode([<span class="string">'name'</span>=&gt; <span class="string">'josh'</span>]);</span><br><span class="line">&#125;);</span><br><span class="line">$app-&gt;dispatch(<span class="string">'/users/josh'</span>);</span><br></pre></td></tr></table></figure></p><blockquote><p>ModernPHP 系列全集：<a href="/modernphp/">传送门</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍PHP中的闭包和匿名函数的概念，以及它们的具体使用。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="php" scheme="https://sidfate.github.io/categories/tech/php/"/>
    
    
      <category term="PHP" scheme="https://sidfate.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>ModernPHP 生成器</title>
    <link href="https://sidfate.github.io/2016/08/28/tech/php/modernphp-generator/"/>
    <id>https://sidfate.github.io/2016/08/28/tech/php/modernphp-generator/</id>
    <published>2016-08-28T08:39:00.000Z</published>
    <updated>2018-10-12T10:50:01.837Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍PHP中生成器的概念，以及它的应用。<br><a id="more"></a></p><h3 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h3><p>PHP生成器是PHP5.5.0引入的功能，生成器就是简单的迭代器，但与标准的PHP迭代器不同，PHP生成器不要求实现Iterator接口，从而减轻了类的负担。生成器会根据需求计算并产出要迭代的值，这对应用性能的影响重大。假如标准的PHP迭代器经常在内存中执行迭代操作，这要预先计算出数据集，性能低下；如果要使用特定的方式计算大量数据，对性能的影响更甚。此时我们使用生成器，即时计算出产出后续值，不占用宝贵的内存资源。</p><p>PHP生成器不能满足所有迭代操作的需求，因为如果不查询，生成器永远不知道下一个要迭代的值是什么，在生成器中无法快进或后退。生成器还是一次性的，无法多次迭代同一个生成器。不过，如果需要，可以重建或克隆生成器。</p><h3 id="0x01-生成器的创建"><a href="#0x01-生成器的创建" class="headerlink" title="0x01 生成器的创建"></a>0x01 生成器的创建</h3><p>生成器的创建很简单，因为生成器就是PHP函数，只不过要在函数中一次或多次使用yield关键字。与普通的PHP函数不同的是，生成器从不返回值，只产出值。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'value1'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'value2'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'value3'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用生成器函数时，PHP会返回一个属于Generator类的对象。这个对象可以使用foreach()函数迭代。每次迭代，PHP会要求Generator实例计算并提供下一个要迭代的值。生成器的优雅体现在，每次产出一个值后，生成器的内部状态会停顿；向生成器请求下一个值时，内部状态又会恢复。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> ($myGenerator <span class="keyword">as</span> $yieldedValue) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $yieldedValue, PHP_EOL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// value1</span></span><br><span class="line"><span class="comment">// value2</span></span><br><span class="line"><span class="comment">// value3</span></span><br></pre></td></tr></table></figure></p><h3 id="0x02-生成器的使用"><a href="#0x02-生成器的使用" class="headerlink" title="0x02 生成器的使用"></a>0x02 生成器的使用</h3><p>下面我们来实现一个简单的函数，用于生成一个大范围内数值集合。</p><p>一个普通的栗子：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRange</span><span class="params">($length)</span> </span>&#123;</span><br><span class="line">    $dataset = [];</span><br><span class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>; $i&lt;$length; $i++) &#123;</span><br><span class="line">        $dataset[] = $i;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> $dataset;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$customRange = makeRange(<span class="number">1000000</span>);</span><br><span class="line"><span class="keyword">foreach</span> ($customRange <span class="keyword">as</span> $i) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $i, PHP_EOL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述的代码没有善用内存，因为makeRange()函数要为预先创建的一个有一百万个整数组成的数组分配内存。PHP生成器实现相同的操作。不过一个只会为一个整数分配内存。</p><p>使用生成器的栗子：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRange</span><span class="params">($length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>; $i&lt;$length; $i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> $i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">foreach</span> (makeRange(<span class="number">1000000</span>) <span class="keyword">as</span> $i) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $i, PHP_EOL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这只是一个虚构的例子，在现实中，你可以想象一下使用生成器可以计算什么样的数据集。假设我们现在想迭代一个4GB的文本文件（例如黑客字典），而你的内存可能比4GB还小，这时候就不能把整个文件加载到内存中，下面使用生成器来实现读取一个cvs文件。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRows</span><span class="params">($file)</span> </span>&#123;</span><br><span class="line">    $handle = fopen($file, <span class="string">'rb'</span>);</span><br><span class="line">    <span class="keyword">if</span>($handle === <span class="keyword">false</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(feof($handle) === <span class="keyword">false</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> fgetcsv($handle);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose($handle);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">foreach</span> (getRows(<span class="string">'data.csv'</span>) <span class="keyword">as</span> $row) &#123;</span><br><span class="line">    print_r($row);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子一次只会为csv文件的一行分配内存。迭代大型数据集或者数列时最适合使用生成器，因为这样占用的系统内存量极少。</p><blockquote><p>ModernPHP 系列全集：<a href="/modernphp/">传送门</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍PHP中生成器的概念，以及它的应用。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="php" scheme="https://sidfate.github.io/categories/tech/php/"/>
    
    
      <category term="PHP" scheme="https://sidfate.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>ModernPHP 性状</title>
    <link href="https://sidfate.github.io/2016/08/28/tech/php/modernphp-trait/"/>
    <id>https://sidfate.github.io/2016/08/28/tech/php/modernphp-trait/</id>
    <published>2016-08-28T06:30:00.000Z</published>
    <updated>2018-10-12T10:56:56.492Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲述了何谓性状，以及PHP中性状出现的意义，怎么去使用。<br><a id="more"></a></p><h3 id="0x00-性状是什么"><a href="#0x00-性状是什么" class="headerlink" title="0x00 性状是什么"></a>0x00 性状是什么</h3><p>这是PHP5.4.0引入的概念，既像类又像接口。性状是类的部分实现（即常量，属性和方法），可以混入一个或多个类中。性状有两个作用：表名类可以做什么（像是接口），提供模块化的实现（像是类）。</p><h3 id="0x01-性状的作用"><a href="#0x01-性状的作用" class="headerlink" title="0x01 性状的作用"></a>0x01 性状的作用</h3><p>PHP语言使用的是典型的继承模型。在这个模型中，我们先创建基类，实现基本的功能，然后扩展这个基类，通过继承基类创建更多具体的类。这叫做继承层次结构，很多编程语言都是用这个模式。</p><p>但是，如果想让两个无关的PHP类具有类型的行为，应该如何去做？例如，Satellite（卫星类）和Car（汽车类）两个类的作用十分不同，在继承层次结构上没有共同的父类，但是这两个类应该都能使用地理编码技术转换成经纬度，然后在地图上显示。</p><p>这时候就可以使用性状来解决。性状可以把模块化的实现方式注入到多个无关的类中，还能促进代码的重用。</p><h3 id="0x02-性状的创建"><a href="#0x02-性状的创建" class="headerlink" title="0x02 性状的创建"></a>0x02 性状的创建</h3><p>定义一个性状：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">trait</span> MyTrait &#123;</span><br><span class="line">    <span class="comment">// 实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们接着使用上面提到的例子来演示如何使用性状。我们希望Satellite和Car类都能提供地理编码功能，而且意识到继承和接口都不是最佳方案。我们选择创建Geocodable（地理编码）性状，返回经纬度，然后在地图中绘制。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">trait</span> Geocodable &#123;</span><br><span class="line">    <span class="comment">/* <span class="doctag">@var</span> string */</span></span><br><span class="line">    <span class="keyword">protected</span> $address;</span><br><span class="line">    <span class="comment">/* <span class="doctag">@var</span> \Geocoder\Geocoder */</span></span><br><span class="line">    <span class="keyword">protected</span> $geocoder;</span><br><span class="line">    <span class="comment">/* <span class="doctag">@var</span> \Geocoder\Result\Geocoded */</span></span><br><span class="line">    <span class="keyword">protected</span> $geocoderResult;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setGeocoder</span><span class="params">(\Geocoder\GeocoderInterface $geocoder)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;geocoder = $geocoder;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setAddress</span><span class="params">($address)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;address = $address;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getLatitude</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;geocoderResult)) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;geocodeAddress();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;geocoderResult-&gt;getLatitude();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getLongitude</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;geocoderResult)) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;geocodeAddress();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;geocoderResult-&gt;getLongitude();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">geocodeAddress</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;geocoderResult = <span class="keyword">$this</span>-&gt;geocoder-&gt;geocode(<span class="keyword">$this</span>-&gt;address);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个Geocodable性状定义了三个类属性：一个表示地址；一个是地理编码器对象（\Geocoder\Geocoder类的实例，这个类是来自第三方的组件）；一个是地理编码器处理后的结果对象（\Geocoder\Result\Geocoded类的实例）。我们还定义了4个公有方法和一个受保护的方法。setGeocoder()方法用于注入Geocoder对象；setAddress()方法用于设定地址；getLatitude()和getLongitude()用于返回经纬度；geocodeAddress()方法把地址字符串传给Geocoder实例，获取地理编码器处理的结果。</p><h3 id="0x03-性状的使用"><a href="#0x03-性状的使用" class="headerlink" title="0x03 性状的使用"></a>0x03 性状的使用</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">MyTrait</span>;</span><br><span class="line">    <span class="comment">// 类的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意，PHP解释器在编译的时候会把性状复制黏贴到类的定义体中，但是不会处理这个操作引入的不兼容问题。如果性状假定类中有特定的方法或属性（在性状中没有定义），要确保相应的类中有对应的属性和方法。</p><blockquote><p>ModernPHP 系列全集：<a href="/modernphp/">传送门</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文讲述了何谓性状，以及PHP中性状出现的意义，怎么去使用。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ModernPHP 命名空间</title>
    <link href="https://sidfate.github.io/2016/08/27/tech/php/modernphp-namespace/"/>
    <id>https://sidfate.github.io/2016/08/27/tech/php/modernphp-namespace/</id>
    <published>2016-08-27T08:28:00.000Z</published>
    <updated>2018-10-12T10:56:34.395Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍PHP中命名空间的相关使用和概念。<br><a id="more"></a></p><h3 id="0x00-声明"><a href="#0x00-声明" class="headerlink" title="0x00 声明"></a>0x00 声明</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Symfony</span>\<span class="title">Component</span>\<span class="title">HttpFoundation</span>;</span><br></pre></td></tr></table></figure><p>这一行代码是PHP命名空间声明语句。声明语句始终应该放在<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PHP命名空间与操作系统的物理文件系统不同，这是一个虚拟的概念，没必要和文件系统的目录结构完全对应。但是，大多数的PHP组件为了兼容广泛使用的[PSR-4自动加载器标准](https://phphub.org/topics/2081)，会把子命名空间放到文件系统的子目录下。</span><br><span class="line"></span><br><span class="line">### 0x01 导入</span><br><span class="line">```php</span><br><span class="line">use Symfony\Component\HttpFoundation\Response;</span><br><span class="line"> </span><br><span class="line">$r = new Response();</span><br></pre></td></tr></table></figure></p><p>当然，你还可以用别名的方式导入：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Symfony</span>\<span class="title">Component</span>\<span class="title">HttpFoundation</span>\<span class="title">Response</span> <span class="title">as</span> <span class="title">Res</span>;</span><br><span class="line"> </span><br><span class="line">$r = <span class="keyword">new</span> Res();</span><br></pre></td></tr></table></figure></p><p>应该在PHP文件顶部使用use关键字导入代码，而且要放在<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">从PHP5.6开始还可以导入函数和常量。导入函数时需要使用use func，导入常量时使用use constant。</span><br><span class="line">```php</span><br><span class="line">use func Namespace\funcName;</span><br><span class="line">use constant Namespace\CONST_NAME;</span><br><span class="line"> </span><br><span class="line">funcName();</span><br><span class="line">echo CONST_NAME;</span><br></pre></td></tr></table></figure></p><h3 id="0x02-全局命名空间"><a href="#0x02-全局命名空间" class="headerlink" title="0x02 全局命名空间"></a>0x02 全局命名空间</h3><p>如果需要在命名空间中引用其他命名空间的类、接口、函数或常量，必须使用完全限定的PHP类名（命名空间+类名），或者使用use关键字提前导入至当前命名空间。</p><p>有些代码没有命名空间，这些代码在全局命名空间中，例如PHP原生的Exception类。在命名空间中引入全局命名空间的代码时，需要在类、接口、函数或者常量前加上\符号。例如下面这个例子中，<figure class="highlight plain"><figcaption><span>方法会报错，因为PHP会去搜索当前命名空间下的Exception，也就是会去搜索\My\Space\Foo\Exception类，但是这个类不存在。因此我们需要在Exception类前加上\前缀，表名要去全局命名空间中查找该类。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">一个错误的栗子：</span><br><span class="line">```php</span><br><span class="line">namespace My\Space;</span><br><span class="line">class Foo()</span><br><span class="line">&#123;</span><br><span class="line">    public function run()</span><br><span class="line">    &#123;</span><br><span class="line">        $e = new Exception();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>真确的栗子：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">My</span>\<span class="title">Space</span>;</span><br><span class="line">class Foo()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $e = <span class="keyword">new</span> \<span class="keyword">Exception</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>ModernPHP 系列全集：<a href="/modernphp/">传送门</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍PHP中命名空间的相关使用和概念。&lt;br&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="php" scheme="https://sidfate.github.io/categories/tech/php/"/>
    
    
      <category term="PHP" scheme="https://sidfate.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Apache 开启.htaccess</title>
    <link href="https://sidfate.github.io/2016/08/03/tech/devops/apache-start-htaccess/"/>
    <id>https://sidfate.github.io/2016/08/03/tech/devops/apache-start-htaccess/</id>
    <published>2016-08-03T09:34:00.000Z</published>
    <updated>2018-10-12T10:13:50.890Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍apache开启htaccess配置的方法。</p><a id="more"></a><h3 id="0x00-开始"><a href="#0x00-开始" class="headerlink" title="0x00 开始"></a>0x00 开始</h3><ol><li>找到apache配置文件<code>httpd.conf</code>，找到 </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#LoadModule rewrite_module modules/mod_rewrite.so</span><br></pre></td></tr></table></figure><p>去掉前面的注释符号#。并确认apache安装目录下的modules文件夹中是否有<code>mod_rewrite.so</code>这个文件。这样就启用了Mod Rewrite功能。</p><ol start="2"><li>搜索AllowOverride，找到以下类似配置</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory /&gt;</span><br><span class="line">Options FollowSymLinks</span><br><span class="line">AllowOverride None</span><br><span class="line">Order deny,allow</span><br><span class="line">Deny from all</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure><p>把<code>AllowOverride None</code>改成<code>AllowOverride All</code>，这样所有的文件夹都支持.htaccess了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍apache开启htaccess配置的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="devops" scheme="https://sidfate.github.io/categories/tech/devops/"/>
    
    
      <category term="Apache" scheme="https://sidfate.github.io/tags/Apache/"/>
    
  </entry>
  
  <entry>
    <title>PHP $GLOBALS变量和global关键字</title>
    <link href="https://sidfate.github.io/2015/04/11/tech/php/php-globals-and-global/"/>
    <id>https://sidfate.github.io/2015/04/11/tech/php/php-globals-and-global/</id>
    <published>2015-04-11T09:55:00.000Z</published>
    <updated>2018-10-12T10:13:59.125Z</updated>
    
    <content type="html"><![CDATA[<p>$GLOBALS[‘var’]是外部的全局变量本身；global $var是外部$var的同名引用或者指针。</p><a id="more"></a><h3 id="0x00-代码演示"><a href="#0x00-代码演示" class="headerlink" title="0x00 代码演示"></a>0x00 代码演示</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $var1 = <span class="number">1</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test1</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">unset</span>($GLOBALS[<span class="string">'var1'</span>]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    test1();  </span><br><span class="line">    <span class="keyword">echo</span> $var1;  </span><br><span class="line"></span><br><span class="line">    $var2 = <span class="number">2</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test2</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">global</span>  $var2;  </span><br><span class="line">        <span class="keyword">unset</span>($var2);  </span><br><span class="line">    &#125;  </span><br><span class="line">    test2();  </span><br><span class="line">    <span class="keyword">echo</span> $var2;</span><br></pre></td></tr></table></figure><h3 id="0x01-结论"><a href="#0x01-结论" class="headerlink" title="0x01 结论"></a>0x01 结论</h3><p>上述代码最终的打印结果只打印了“2”。test1中unset了$var1，因此外部也访问不到，而test2中unset的只是$var2的同名引用，所以外部的变量还存在，这说明了$GLOBALS变量和global关键字两者的机制还是不同的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;$GLOBALS[‘var’]是外部的全局变量本身；global $var是外部$var的同名引用或者指针。&lt;/p&gt;
    
    </summary>
    
      <category term="tech" scheme="https://sidfate.github.io/categories/tech/"/>
    
      <category term="php" scheme="https://sidfate.github.io/categories/tech/php/"/>
    
    
      <category term="PHP" scheme="https://sidfate.github.io/tags/PHP/"/>
    
  </entry>
  
</feed>
